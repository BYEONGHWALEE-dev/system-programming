{\rtf1\ansi\ansicpg949\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red108\green121\blue134;\red31\green31\blue36;\red255\green255\blue255;
\red253\green143\blue63;\red252\green106\blue93;\red158\green241\blue221;\red252\green95\blue163;\red65\green161\blue192;
\red208\green191\blue105;\red208\green191\blue105;\red103\green183\blue164;\red103\green183\blue164;\red161\green103\blue230;
\red253\green143\blue63;\red208\green168\blue255;}
{\*\expandedcolortbl;;\csgenericrgb\c42394\c47462\c52518;\csgenericrgb\c12054\c12284\c14131;\csgenericrgb\c100000\c100000\c100000\c85000;
\csgenericrgb\c99131\c56076\c24611;\csgenericrgb\c98912\c41558\c36568;\csgenericrgb\c62145\c94386\c86819;\csgenericrgb\c98839\c37355\c63833;\csgenericrgb\c25490\c63137\c75294;
\csgenericrgb\c81498\c74939\c41233;\csgenericrgb\c81569\c74902\c41177;\csgenericrgb\c40392\c71765\c64314;\csgenericrgb\c40538\c71705\c64209;\csgenericrgb\c63137\c40392\c90196;
\csgenericrgb\c99216\c56078\c24706;\csgenericrgb\c81681\c65692\c99927;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab593
\pard\tx593\pardeftab593\partightenfactor0

\f0\fs24 \cf2 \cb3 /*\cf4 \
\cf2  * \uc0\u54028 \u51068 \u47749  : my_assembler_00000000.c\cf4 \
\cf2  * \uc0\u49444   \u47749  : \u51060  \u54532 \u47196 \u44536 \u47016 \u51008  SIC/XE \u47672 \u49888 \u51012  \u50948 \u54620  \u44036 \u45800 \u54620  Assembler \u54532 \u47196 \u44536 \u47016 \u51032  \u47700 \u51064 \u47336 \u54004 \u51004 \u47196 ,\cf4 \
\cf2  * \uc0\u51077 \u47141 \u46108  \u54028 \u51068 \u51032  \u53076 \u46300  \u51473 , \u47749 \u47161 \u50612 \u50640  \u54644 \u45817 \u54616 \u45716  OPCODE\u47484  \u52286 \u50500  \u52636 \u47141 \u54620 \u45796 .\cf4 \
\cf2  * \uc0\u54028 \u51068  \u45236 \u50640 \u49436  \u49324 \u50857 \u46104 \u45716  \u47928 \u51088 \u50676  "00000000"\u50640 \u45716  \u51088 \u49888 \u51032  \u54617 \u48264 \u51012  \u44592 \u51077 \u54620 \u45796 .\cf4 \
\cf2  */\cf4 \
\
\cf2 /*\cf4 \
\cf2  *\cf4 \
\cf2  * \uc0\u54532 \u47196 \u44536 \u47016 \u51032  \u54756 \u45908 \u47484  \u51221 \u51032 \u54620 \u45796 .\cf4 \
\cf2  *\cf4 \
\cf2  */\cf4 \
\
\cf5 #include \cf6 <stdio.h>\cf4 \
\cf5 #include \cf6 <stdlib.h>\cf4 \
\cf5 #include \cf6 <string.h>\cf4 \
\cf5 #include \cf6 <fcntl.h>\cf4 \
\cf5 #include \cf6 <ctype.h>\cf4 \
\
\cf5 #include \cf6 "my_assembler_20201551.h"\cf4 \
\
\cf2 // \uc0\u51204 \u50669  \u48320 \u49688  \u51221 \u51032  (\u54756 \u45908 \u50640 \u49436  extern\u51004 \u47196  \u49440 \u50616 \u46108  \u44163 \u46308 )\cf4 \
\cf7 inst\cf4 * inst_table[\cf5 MAX_INST\cf4 ];\

\f1\b \cf8 int
\f0\b0 \cf4  inst_index;\
\

\f1\b \cf8 char
\f0\b0 \cf4 * input_data[\cf5 MAX_LINES\cf4 ];\

\f1\b \cf8 int
\f0\b0 \cf4  line_num;\
\
\cf7 token\cf4 * token_table[\cf5 MAX_LINES\cf4 ];\

\f1\b \cf8 int
\f0\b0 \cf4  token_line;\
\
\cf7 symbol\cf4  sym_table[\cf5 MAX_LINES\cf4 ];\

\f1\b \cf8 int
\f0\b0 \cf4  sym_index;\
\
\cf7 literal\cf4  literal_table[\cf5 MAX_LINES\cf4 ];\

\f1\b \cf8 int
\f0\b0 \cf4  literal_index;\
\

\f1\b \cf8 char
\f0\b0 \cf4 * extdef_table[\cf5 MAX_OPERAND\cf4 ];\

\f1\b \cf8 int
\f0\b0 \cf4  extdef_index;\

\f1\b \cf8 char
\f0\b0 \cf4 * extref_table[MAX_OPERAND];\

\f1\b \cf8 int
\f0\b0 \cf4  extref_index;\
\

\f1\b \cf8 char
\f0\b0 \cf4  num_operator;\

\f1\b \cf8 int
\f0\b0 \cf4  locctr;\
\

\f1\b \cf8 char
\f0\b0 \cf4 * extref_2_table[MAX_OPERAND];\

\f1\b \cf8 int
\f0\b0 \cf4  extref_2_index;\
\

\f1\b \cf8 int
\f0\b0 \cf4  literal_written[MAX_LINES];\
\

\f1\b \cf8 char
\f0\b0 \cf4 * input_file;\

\f1\b \cf8 char
\f0\b0 \cf4 * output_file;\
\

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 main\cf4 (
\f1\b \cf8 int
\f0\b0 \cf4  args, 
\f1\b \cf8 char
\f0\b0 \cf4  *arg[])\
\{\
   
\f1\b \cf8 if
\f0\b0 \cf4  (init_my_assembler() < \cf10 0\cf4 )\
   \{\
      printf(\cf6 "init_my_assembler: \uc0\u54532 \u47196 \u44536 \u47016  \u52488 \u44592 \u54868 \u50640  \u49892 \u54056  \u54664 \u49845 \u45768 \u45796 .\\n"\cf4 );\
      
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
   \}\
\
   
\f1\b \cf8 if
\f0\b0 \cf4  (assem_pass1() < \cf10 0\cf4 )\
   \{\
      printf(\cf6 "assem_pass1: \uc0\u54056 \u49828 1 \u44284 \u51221 \u50640 \u49436  \u49892 \u54056 \u54616 \u50688 \u49845 \u45768 \u45796 .  \\n"\cf4 );\
      
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
   \}\
\
    make_symtab_output(
\f1\b \cf8 NULL
\f0\b0 \cf4 );\
    make_literaltab_output(
\f1\b \cf8 NULL
\f0\b0 \cf4 );\
\
   
\f1\b \cf8 if
\f0\b0 \cf4  (assem_pass2() < \cf10 0\cf4 )\
   \{\
      printf(\cf6 " assem_pass2: \uc0\u54056 \u49828 2 \u44284 \u51221 \u50640 \u49436  \u49892 \u54056 \u54616 \u50688 \u49845 \u45768 \u45796 .  \\n"\cf4 );\
      
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
   \}\
\
    make_objectcode_output(
\f1\b \cf8 NULL
\f0\b0 \cf4 );\
   \
   
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;\
\}\
\
\cf2 // \uc0\u44060 \u48324 \u47196  \u47564 \u46304  \u54632 \u49688 \cf4 \
\cf2 // \uc0\u53664 \u53360 \u50640  \u44060 \u54665  \u47928 \u51088 \u47484  \u47784 \u46160  \u49325 \u51228 \u54616 \u44256  \u53580 \u51060 \u48660 \u50640  \u45347 \u46020 \u47197  \u54616 \u44592  \u50948 \u54644  \u47564 \u46310 \cf4 \

\f1\b \cf8 void
\f0\b0 \cf4  \cf9 trim\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4 * s) \{\
    s[strcspn(s, \cf6 "\\n\\r\\t "\cf4 )] = \cf11 '\\0'\cf4 ;  \cf2 // \uc0\u50526 \u50640 \u49436  \u52376 \u51020  \u45208 \u50724 \u45716  \u53945 \u49688 \u47928 \u51088  \u50948 \u52824 \u47484  '\\0' \u52376 \u47532 \cf4 \
\}\
\
\cf2 // \uc0\u47928 \u51088 \u50676 \u50640 \u49436  \u49788 \u54364 \u47196  \u44396 \u48516 \u46108  \u53664 \u53360 \u51012  \u52628 \u52636 \u54644  \u48176 \u50676 \u50640  \u51200 \u51109 \cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 sep_by_comma\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4 * line, 
\f1\b \cf8 char
\f0\b0 \cf4 * output[], 
\f1\b \cf8 int
\f0\b0 \cf4  max_symbols) \{\
    
\f1\b \cf8 char
\f0\b0 \cf4  buffer[\cf10 256\cf4 ];\
    strncpy(buffer, line, 
\f1\b \cf8 sizeof
\f0\b0 \cf4 (buffer));\
    buffer[
\f1\b \cf8 sizeof
\f0\b0 \cf4 (buffer) - \cf10 1\cf4 ] = \cf11 '\\0'\cf4 ;\
\
    
\f1\b \cf8 char
\f0\b0 \cf4 * token = strtok(buffer, \cf6 ","\cf4 );\
    
\f1\b \cf8 int
\f0\b0 \cf4  count = \cf10 0\cf4 ;\
\
    
\f1\b \cf8 while
\f0\b0 \cf4  (token != 
\f1\b \cf8 NULL
\f0\b0 \cf4  && count < max_symbols) \{\
        
\f1\b \cf8 while
\f0\b0 \cf4  (isspace((
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 )*token)) token++; \cf2 // \uc0\u50526  \u44277 \u48177  \u51228 \u44144 \cf4 \
\
        output[count] = (
\f1\b \cf8 char
\f0\b0 \cf4 *)malloc(strlen(token) + \cf10 1\cf4 );\
        strcpy(output[count], token);\
        count++;\
\
        token = strtok(
\f1\b \cf8 NULL
\f0\b0 \cf4 , \cf6 ","\cf4 );\
    \}\
\
    
\f1\b \cf8 return
\f0\b0 \cf4  count; \cf2 // \uc0\u49892 \u51228  \u51200 \u51109 \u46108  \u49900 \u48380  \u49688 \cf4 \
\}\
\
\cf2 /* ----------------------------------------------------------------------------------\cf4 \
\cf2  * \uc0\u49444 \u47749  : \u54532 \u47196 \u44536 \u47016  \u52488 \u44592 \u54868 \u47484  \u50948 \u54620  \u51088 \u47308 \u44396 \u51312  \u49373 \u49457  \u48143  \u54028 \u51068 \u51012  \u51069 \u45716  \u54632 \u49688 \u51060 \u45796 .\cf4 \
\cf2  * \uc0\u47588 \u44228  : \u50630 \u51020 \cf4 \
\cf2  * \uc0\u48152 \u54872  : \u51221 \u49345 \u51333 \u47308  = 0 , \u50640 \u47084  \u48156 \u49373  = -1\cf4 \
\cf2  * \uc0\u51452 \u51032  : \u44033 \u44033 \u51032  \u47749 \u47161 \u50612  \u53580 \u51060 \u48660 \u51012  \u45236 \u48512 \u50640  \u49440 \u50616 \u54616 \u51648  \u50506 \u44256  \u44288 \u47532 \u47484  \u50857 \u51060 \u54616 \u44172  \u54616 \u44592 \cf4 \
\cf2  *         \uc0\u50948 \u54644 \u49436  \u54028 \u51068  \u45800 \u50948 \u47196  \u44288 \u47532 \u54616 \u50668  \u54532 \u47196 \u44536 \u47016  \u52488 \u44592 \u54868 \u47484  \u53685 \u54644  \u51221 \u48372 \u47484  \u51069 \u50612  \u50732  \u49688  \u51080 \u46020 \u47197 \cf4 \
\cf2  *         \uc0\u44396 \u54788 \u54616 \u50688 \u45796 .\cf4 \
\cf2  * ----------------------------------------------------------------------------------\cf4 \
\cf2  */\cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 init_my_assembler\cf4 (
\f1\b \cf8 void
\f0\b0 \cf4 )\
\{\
   
\f1\b \cf8 int
\f0\b0 \cf4  result;\
\
   
\f1\b \cf8 if
\f0\b0 \cf4  ((result = init_inst_file(\cf6 "inst_table.txt"\cf4 )) < \cf10 0\cf4 )\
      
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
   
\f1\b \cf8 if
\f0\b0 \cf4  ((result = init_input_file(\cf6 "input-1.txt"\cf4 )) < \cf10 0\cf4 )\
      
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
   
\f1\b \cf8 return
\f0\b0 \cf4  result;\
\}\
\
\cf2 /* ----------------------------------------------------------------------------------\cf4 \
\cf2  * \uc0\u49444 \u47749  : \u47672 \u49888 \u51012  \u50948 \u54620  \u44592 \u44228  \u53076 \u46300 \u47785 \u47197  \u54028 \u51068 (inst_table.txt)\u51012  \u51069 \u50612 \cf4 \
\cf2  *       \uc0\u44592 \u44228 \u50612  \u47785 \u47197  \u53580 \u51060 \u48660 (inst_table)\u51012  \u49373 \u49457 \u54616 \u45716  \u54632 \u49688 \u51060 \u45796 .\cf4 \
\cf2  *\cf4 \
\cf2  *\cf4 \
\cf2  * \uc0\u47588 \u44228  : \u44592 \u44228 \u50612  \u47785 \u47197  \u54028 \u51068 \cf4 \
\cf2  * \uc0\u48152 \u54872  : \u51221 \u49345 \u51333 \u47308  = 0 , \u50640 \u47084  < 0\cf4 \
\cf2  * \uc0\u51452 \u51032  : \u44592 \u44228 \u50612  \u47785 \u47197 \u54028 \u51068  \u54805 \u49885 \u51008  \u51088 \u50976 \u47213 \u44172  \u44396 \u54788 \u54620 \u45796 . \u50696 \u49884 \u45716  \u45796 \u51020 \u44284  \u44057 \u45796 .\cf4 \
\cf2  *\cf4 \
\cf2  *   ===============================================================================\cf4 \
\cf2  *         | \uc0\u51060 \u47492  | \u54805 \u49885  | \u44592 \u44228 \u50612  \u53076 \u46300  | \u50724 \u54140 \u47004 \u46300 \u51032  \u44079 \u49688  | \\n |\cf4 \
\cf2  *   ===============================================================================\cf4 \
\cf2  *\cf4 \
\cf2  * ----------------------------------------------------------------------------------\cf4 \
\cf2  */\cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 init_inst_file\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4  *inst_file)\
\{\
    FILE* file;\
    \
    
\f1\b \cf8 char
\f0\b0 \cf4  mnemonic[\cf10 10\cf4 ];\
    
\f1\b \cf8 int
\f0\b0 \cf4  format;\
    
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 int
\f0\b0 \cf4  opcode;\
    
\f1\b \cf8 int
\f0\b0 \cf4  ops;\
    \
    inst_index = \cf10 0\cf4 ;\
    \
    file = fopen(inst_file, \cf6 "r"\cf4 );\
    
\f1\b \cf8 if
\f0\b0 \cf4 (file == 
\f1\b \cf8 NULL
\f0\b0 \cf4 )\{\
        perror(\cf6 "inst_table.txt \uc0\u54028 \u51068  \u50676 \u44592  \u49892 \u54056 "\cf4 );\
        
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
    \}\
    \
    
\f1\b \cf8 while
\f0\b0 \cf4 (fscanf(file, \cf6 "%s %d %x %d"\cf4 , mnemonic, &format, &opcode, &ops) == \cf10 4\cf4 )\{ \cf2 // inst_table \uc0\u54028 \u51068 \u51012  \u47564 \u46304 \u45796 . -> \u51060 \u44148  \u51649 \u51217  \u54028 \u51068 \u51012  \u47564 \u46308 \u50612 \u50556  \u54632 .\cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4 (inst_index >= MAX_INST)\{\
            printf(\cf6 "inst_table\uc0\u51032  \u52572 \u45824  \u53356 \u44592 \u47484  \u52488 \u44284 \u54616 \u50688 \u49845 \u45768 \u45796 .\\n"\cf4 );\
            
\f1\b \cf8 break
\f0\b0 \cf4 ;\
        \}\
        \
        inst* new_inst = (inst*)malloc(
\f1\b \cf8 sizeof
\f0\b0 \cf4 (inst));\
        
\f1\b \cf8 if
\f0\b0 \cf4 (new_inst == 
\f1\b \cf8 NULL
\f0\b0 \cf4 )\{\
            perror(\cf6 "inst \uc0\u44396 \u51312 \u52404  \u47700 \u47784 \u47532  \u54624 \u45817  \u49892 \u54056 "\cf4 );\
            fclose(file);\
            
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
        \}\
        \
        \cf2 // \uc0\u54620 \u51460  \u50473  Instruction\u51012  \u51069 \u44256  new_inst\u46972 \u45716  \u44061 \u52404  \u50504 \u50640  mnemonic, format, op, ops\u47196  \u51200 \u51109 \u54620 \u45796 .\cf4 \
        strcpy(new_inst->str, mnemonic);\
        new_inst->format = format; \cf2 //\cf4 \
        new_inst->op = (
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 )opcode;\
        new_inst->ops = ops;\
        \
        inst_table[inst_index++] = new_inst;\
    \}\
    \
    fclose(file);\
    
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;  \cf2 // \uc0\u51221 \u49345  \u51333 \u47308 \}\cf4 \
\}\
\cf2 /* ----------------------------------------------------------------------------------\cf4 \
\cf2  * \uc0\u49444 \u47749  : \u50612 \u49480 \u48660 \u47532  \u54624  \u49548 \u49828 \u53076 \u46300 \u47484  \u51069 \u50612  \u49548 \u49828 \u53076 \u46300  \u53580 \u51060 \u48660 (input_data)\u47484  \u49373 \u49457 \u54616 \u45716  \u54632 \u49688 \u51060 \u45796 .\cf4 \
\cf2  * \uc0\u47588 \u44228  : \u50612 \u49480 \u48660 \u47532 \u54624  \u49548 \u49828 \u54028 \u51068 \u47749 \cf4 \
\cf2  * \uc0\u48152 \u54872  : \u51221 \u49345 \u51333 \u47308  = 0 , \u50640 \u47084  < 0\cf4 \
\cf2  * \uc0\u51452 \u51032  : \u46972 \u51064 \u45800 \u50948 \u47196  \u51200 \u51109 \u54620 \u45796 .\cf4 \
\cf2  *\cf4 \
\cf2  * ----------------------------------------------------------------------------------\cf4 \
\cf2  */\cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 init_input_file\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4  *input_file)\
\{\
    FILE* file;\
\
    \cf2 /* add your code here */\cf4 \
    
\f1\b \cf8 char
\f0\b0 \cf4  buffer[\cf10 256\cf4 ];\
    line_num = \cf10 0\cf4 ;\
    \
    file = fopen(input_file, \cf6 "r"\cf4 );\
    
\f1\b \cf8 if
\f0\b0 \cf4  (file == 
\f1\b \cf8 NULL
\f0\b0 \cf4 )\
    \{\
        perror(\cf6 "\uc0\u54028 \u51068  \u50676 \u44592  \u49892 \u54056 "\cf4 );\
        
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
    \}\
    \
    
\f1\b \cf8 while
\f0\b0 \cf4 (fgets(buffer, 
\f1\b \cf8 sizeof
\f0\b0 \cf4 (buffer), file)) \cf2 // \uc0\u54620  \u51460 \u50473 \cf4 \
    \{\
        
\f1\b \cf8 if
\f0\b0 \cf4 (line_num >= MAX_LINES)\{\
            printf(\cf6 "\uc0\u51077 \u47141  \u46972 \u51064 \u51060  MAX_LINES\u47484  \u52488 \u44284 \u54616 \u50688 \u49845 \u45768 \u45796 .\\n"\cf4 );\
            
\f1\b \cf8 break
\f0\b0 \cf4 ;\
        \}\
        \
        buffer[strcspn(buffer, \cf6 "\\n"\cf4 )] = \cf11 '\\0'\cf4 ; \cf2 //strcspn\uc0\u51004 \u47196  "\\n" \u51064 \u45937 \u49828  \u48152 \u54872  \u54980  "\\n" -> '\\0'\cf4 \
        \
        input_data[line_num] = (
\f1\b \cf8 char
\f0\b0 \cf4 *)malloc(strlen(buffer) + \cf10 1\cf4 );\
        
\f1\b \cf8 if
\f0\b0 \cf4 (input_data[line_num] == 
\f1\b \cf8 NULL
\f0\b0 \cf4 )\
        \{\
            perror(\cf6 "\uc0\u47700 \u47784 \u47532  \u54624 \u45817  \u49892 \u54056 "\cf4 );\
            fclose(file);\
            
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
        \}\
        \
        strcpy(input_data[line_num++], buffer);\
\
    \}\
    \
    fclose(file);\
\
    
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;\
\}\
\
\cf2 /* ----------------------------------------------------------------------------------\cf4 \
\cf2  * \uc0\u49444 \u47749  : \u49548 \u49828  \u53076 \u46300 \u47484  \u51069 \u50612 \u50752  \u53664 \u53360 \u45800 \u50948 \u47196  \u48516 \u49437 \u54616 \u44256  \u53664 \u53360  \u53580 \u51060 \u48660 \u51012  \u51089 \u49457 \u54616 \u45716  \u54632 \u49688 \u51060 \u45796 .\cf4 \
\cf2  *        \uc0\u54056 \u49828  1\u47196  \u48512 \u53552  \u54840 \u52636 \u46108 \u45796 .\cf4 \
\cf2  * \uc0\u47588 \u44228  : \u54028 \u49905 \u51012  \u50896 \u54616 \u45716  \u47928 \u51088 \u50676 \cf4 \
\cf2  * \uc0\u48152 \u54872  : \u51221 \u49345 \u51333 \u47308  = 0 , \u50640 \u47084  < 0\cf4 \
\cf2  * \uc0\u51452 \u51032  : my_assembler \u54532 \u47196 \u44536 \u47016 \u50640 \u49436 \u45716  \u46972 \u51064 \u45800 \u50948 \u47196  \u53664 \u53360  \u48143  \u50724 \u48652 \u51229 \u53944  \u44288 \u47532 \u47484  \u54616 \u44256  \u51080 \u45796 .\cf4 \
\cf2  * ----------------------------------------------------------------------------------\cf4 \
\cf2  */\cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 is_in_directive_list\cf4 (
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * value) \{\
    
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * direct_list[] = \{\cf6 "LTORG"\cf4 , \cf6 "EXTDEF"\cf4 , \cf6 "EXTREF"\cf4 \};\
    
\f1\b \cf8 int
\f0\b0 \cf4  list_size = 
\f1\b \cf8 sizeof
\f0\b0 \cf4 (direct_list) / 
\f1\b \cf8 sizeof
\f0\b0 \cf4 (direct_list[\cf10 0\cf4 ]);\
\
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < list_size; i++) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(value, direct_list[i]) == \cf10 0\cf4 ) \{\
            
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;  \cf2 // \uc0\u51080 \u51020 \cf4 \
        \}\
    \}\
    
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;  \cf2 // \uc0\u50630 \u51020 \cf4 \
\}\
\

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 token_parsing\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4  *str)\
\{\
    
\f1\b \cf8 if
\f0\b0 \cf4  (token_line >= MAX_LINES) \{\
        printf(\cf6 "token_table \uc0\u53356 \u44592  \u52488 \u44284 \\n"\cf4 );\
        
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
    \}\
\
    token* t = (token*)malloc(
\f1\b \cf8 sizeof
\f0\b0 \cf4 (token));\
    
\f1\b \cf8 if
\f0\b0 \cf4  (!t) \{\
        perror(\cf6 "\uc0\u53664 \u53360  \u47700 \u47784 \u47532  \u54624 \u45817  \u49892 \u54056 "\cf4 );\
        
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
    \}\
\
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < MAX_OPERAND; i++)\
        t->operand[i] = 
\f1\b \cf8 NULL
\f0\b0 \cf4 ;\
\
    t->label = 
\f1\b \cf8 NULL
\f0\b0 \cf4 ;\
    t->operator = 
\f1\b \cf8 NULL
\f0\b0 \cf4 ;\
    strcpy(t->comment, \cf6 ""\cf4 );\
\
    \
    
\f1\b \cf8 char
\f0\b0 \cf4 * tok_list[MAX_COLUMNS + \cf10 1\cf4 ] = \{ 
\f1\b \cf8 NULL
\f0\b0 \cf4 , \};\
    
\f1\b \cf8 int
\f0\b0 \cf4  count = \cf10 0\cf4 ;\
    \
    \cf2 // \uc0\u53664 \u53360  \u48516 \u47532  (\u53485 )\cf4 \
    
\f1\b \cf8 char
\f0\b0 \cf4 * tok = strtok(str, \cf6 "\\t"\cf4 );\
    
\f1\b \cf8 while
\f0\b0 \cf4  (tok != 
\f1\b \cf8 NULL
\f0\b0 \cf4  && count < MAX_COLUMNS + \cf10 1\cf4 ) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4  (tok[\cf10 0\cf4 ] == \cf11 '.'\cf4 ) \{\
            
\f1\b \cf8 break
\f0\b0 \cf4 ;\
        \}\
        tok[strcspn(tok,\cf6 "\\n"\cf4 )] = \cf11 '\\0'\cf4 ;\
        tok_list[count++] = tok;\
        tok = strtok(
\f1\b \cf8 NULL
\f0\b0 \cf4 , \cf6 " \\t"\cf4 );\
    \}\
\
    
\f1\b \cf8 if
\f0\b0 \cf4  (count == \cf10 0\cf4 ) \{\
        token_table[token_line++] = t;\
        
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;\
    \}\
    \
    \cf2 // \uc0\u51665 \u50612 \u45347 \u44592  \u51204 \u50640  \u44060 \u54665  \u47676 \u51200  \u49325 \u51228 \cf4 \
    
\f1\b \cf8 for
\f0\b0 \cf4 (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < count; i++)\{\
        trim(tok_list[i]);\
    \}\
\
    \cf2 // \uc0\u52395  \u53664 \u53360 \u51060  opcode\u51064  \u44221 \u50864  \u8594  label \u50630 \u51020 \cf4 \
    
\f1\b \cf8 int
\f0\b0 \cf4  opcode_idx = search_opcode(tok_list[\cf10 0\cf4 ]);\
    
\f1\b \cf8 int
\f0\b0 \cf4  direct_idx = is_in_directive_list(tok_list[\cf10 0\cf4 ]);\
    
\f1\b \cf8 int
\f0\b0 \cf4  is_label = (opcode_idx < \cf10 0\cf4  && direct_idx < \cf10 0\cf4 ); \cf2 // \uc0\u47749 \u47161 \u50612 \u44032  \u50500 \u45768 \u47732  label \u52712 \u44553 \cf4 \
    \
    \
    \
    \
    
\f1\b \cf8 if
\f0\b0 \cf4  (is_label) \{\
        t->label = strdup(tok_list[\cf10 0\cf4 ]);\
        
\f1\b \cf8 if
\f0\b0 \cf4  (count > \cf10 1\cf4 ) t->operator = strdup(tok_list[\cf10 1\cf4 ]);\
        
\f1\b \cf8 if
\f0\b0 \cf4  (count > \cf10 2\cf4 ) t->operand[\cf10 0\cf4 ] = strdup(tok_list[\cf10 2\cf4 ]);\
        
\f1\b \cf8 if
\f0\b0 \cf4  (count > \cf10 3\cf4 ) t->operand[\cf10 1\cf4 ] = strdup(tok_list[\cf10 3\cf4 ]);\
    \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
        t->label = 
\f1\b \cf8 NULL
\f0\b0 \cf4 ;\
        
\f1\b \cf8 if
\f0\b0 \cf4  (count > \cf10 0\cf4 ) t->operator = strdup(tok_list[\cf10 0\cf4 ]);\
        
\f1\b \cf8 if
\f0\b0 \cf4  (count > \cf10 1\cf4 ) t->operand[\cf10 0\cf4 ] = strdup(tok_list[\cf10 1\cf4 ]);\
        
\f1\b \cf8 if
\f0\b0 \cf4  (count > \cf10 2\cf4 ) t->operand[\cf10 1\cf4 ] = strdup(tok_list[\cf10 2\cf4 ]);\
    \}\
\
    token_table[token_line++] = t;\
    
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;\
\}\
\
\cf2 /* ----------------------------------------------------------------------------------\cf4 \
\cf2  * \uc0\u49444 \u47749  : \u51077 \u47141  \u47928 \u51088 \u50676 \u51060  \u44592 \u44228 \u50612  \u53076 \u46300 \u51064 \u51648 \u47484  \u44160 \u49324 \u54616 \u45716  \u54632 \u49688 \u51060 \u45796 .\cf4 \
\cf2  * \uc0\u47588 \u44228  : \u53664 \u53360  \u45800 \u50948 \u47196  \u44396 \u48516 \u46108  \u47928 \u51088 \u50676 \cf4 \
\cf2  * \uc0\u48152 \u54872  : \u51221 \u49345 \u51333 \u47308  = \u44592 \u44228 \u50612  \u53580 \u51060 \u48660  \u51064 \u45937 \u49828 , \u50640 \u47084  < 0\cf4 \
\cf2  * \uc0\u51452 \u51032  : \u44592 \u44228 \u50612  \u47785 \u47197  \u53580 \u51060 \u48660 \u50640 \u49436  \u53945 \u51221  \u44592 \u44228 \u50612 \u47484  \u44160 \u49353 \u54616 \u50668 , \u54644 \u45817  \u44592 \u44228 \u50612 \u44032  \u50948 \u52824 \u54620  \u51064 \u45937 \u49828 \u47484  \u48152 \u54872 \u54620 \u45796 .\cf4 \
\cf2  *        '+JSUB'\uc0\u44284  \u44057 \u51008  \u47928 \u51088 \u50676 \u50640  \u45824 \u54620  \u52376 \u47532 \u45716  \u51088 \u50976 \u47213 \u44172  \u52376 \u47532 \u54620 \u45796 .\cf4 \
\cf2  *\cf4 \
\cf2  * ----------------------------------------------------------------------------------\cf4 \
\cf2  */\cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 search_opcode\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4  *str)\
\{\
   \cf2 /* add your code here */\cf4 \
    
\f1\b \cf8 char
\f0\b0 \cf4  temp[\cf10 10\cf4 ];\
\
    \cf2 // format 4 \uc0\u47749 \u47161 \u50612 (+\u44592 \u54840  \u51228 \u44144 )\cf4 \
    
\f1\b \cf8 if
\f0\b0 \cf4  (str[\cf10 0\cf4 ] == \cf11 '+'\cf4 ) \{\
        strncpy(temp, str + \cf10 1\cf4 , 
\f1\b \cf8 sizeof
\f0\b0 \cf4 (temp) - \cf10 1\cf4 );\
        temp[
\f1\b \cf8 sizeof
\f0\b0 \cf4 (temp) - \cf10 1\cf4 ] = \cf11 '\\0'\cf4 ;\
    \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
        strncpy(temp, str, 
\f1\b \cf8 sizeof
\f0\b0 \cf4 (temp) - \cf10 1\cf4 );\
        temp[
\f1\b \cf8 sizeof
\f0\b0 \cf4 (temp) - \cf10 1\cf4 ] = \cf11 '\\0'\cf4 ;\
    \}\
\
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < inst_index; i++) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(inst_table[i]->str, temp) == \cf10 0\cf4 ) \{\
            
\f1\b \cf8 return
\f0\b0 \cf4  i;\
        \}\
    \}\
\
    
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;  \cf2 // \uc0\u47749 \u47161 \u50612 \u47484  \u52286 \u51648  \u47803 \u54620  \u44221 \u50864 \cf4 \
\}\
\
\cf2 /* ----------------------------------------------------------------------------------\cf4 \
\cf2 * \uc0\u49444 \u47749  : \u50612 \u49480 \u48660 \u47532  \u53076 \u46300 \u47484  \u50948 \u54620  \u54056 \u49828 1\u44284 \u51221 \u51012  \u49688 \u54665 \u54616 \u45716  \u54632 \u49688 \u51060 \u45796 .\cf4 \
\cf2 *         \uc0\u54056 \u49828 1\u50640 \u49436 \u45716 ..\cf4 \
\cf2 *         1. \uc0\u54532 \u47196 \u44536 \u47016  \u49548 \u49828 \u47484  \u49828 \u52884 \u54616 \u50668  \u54644 \u45817 \u54616 \u45716  \u53664 \u53360 \u45800 \u50948 \u47196  \u48516 \u47532 \u54616 \u50668  \u54532 \u47196 \u44536 \u47016  \u46972 \u51064 \u48324  \u53664 \u53360 \cf4 \
\cf2 *         \uc0\u53580 \u51060 \u48660 \u51012  \u49373 \u49457 \u54620 \u45796 .\cf4 \
\cf2 *          2. \uc0\u53664 \u53360  \u53580 \u51060 \u48660 \u51008  token_parsing()\u51012  \u54840 \u52636 \u54616 \u50668  \u49444 \u51221 \u54620 \u45796 .\cf4 \
\cf2 *          3. assem_pass2 \uc0\u44284 \u51221 \u50640 \u49436  \u49324 \u50857 \u54616 \u44592  \u50948 \u54620  \u49900 \u48380 \u53580 \u51060 \u48660  \u48143  \u47532 \u53552 \u47092  \u53580 \u51060 \u48660 \u51012  \u49373 \u49457 \u54620 \u45796 .\cf4 \
\cf2 *\cf4 \
\cf2 * \uc0\u47588 \u44228  : \u50630 \u51020 \cf4 \
\cf2 * \uc0\u48152 \u54872  : \u51221 \u49345  \u51333 \u47308  = 0 , \u50640 \u47084  = < 0\cf4 \
\cf2 * \uc0\u51452 \u51032  : \u54788 \u51116  \u52488 \u44592  \u48260 \u51204 \u50640 \u49436 \u45716  \u50640 \u47084 \u50640  \u45824 \u54620  \u44160 \u49324 \u47484  \u54616 \u51648  \u50506 \u44256  \u45336 \u50612 \u44036  \u49345 \u53468 \u51060 \u45796 .\cf4 \
\cf2 *     \uc0\u46384 \u46972 \u49436  \u50640 \u47084 \u50640  \u45824 \u54620  \u44160 \u49324  \u47336 \u54004 \u51012  \u52628 \u44032 \u54644 \u50556  \u54620 \u45796 .\cf4 \
\cf2 *\cf4 \
\cf2 * -----------------------------------------------------------------------------------\cf4 \
\cf2 */\cf4 \
\cf2 // extref\uc0\u50640  \u51080 \u45716 \u51648  \u54869 \u51064 \u54616 \u45716  \u54632 \u49688 \cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 is_in_extref_list\cf4 (
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * value) \{\
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < extref_index; i++) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(value, extref_table[i]) == \cf10 0\cf4 ) \{\
            
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;  \cf2 // \uc0\u51080 \u51020 \cf4 \
        \}\
    \}\
    
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;  \cf2 // \uc0\u50630 \u51020 \cf4 \
\}\
\cf2 // extref_2\uc0\u50640  \u51080 \u45716 \u51648  \u54869 \u51064 \u54616 \u45716  \u54632 \u49688 \cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 is_in_extref_2_list\cf4 (
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * value) \{\
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < extref_2_index; i++) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(value, extref_2_table[i]) == \cf10 0\cf4 ) \{\
            
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;  \cf2 // \uc0\u51080 \u51020 \cf4 \
        \}\
    \}\
    
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;  \cf2 // \uc0\u50630 \u51020 \cf4 \
\}\
\cf2 // extdef\uc0\u50640  \u51080 \u45716 \u51648  \u54869 \u51064 \u54616 \u45716  \u54632 \u49688 \cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 is_in_extdef_list\cf4 (
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * value)\{\
    
\f1\b \cf8 for
\f0\b0 \cf4 (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < MAX_OPERAND; i++) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4 (strcmp(value, extdef_table[i]) == \cf10 0\cf4 )\{\
            
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ; \cf2 // \uc0\u51080 \u51020 \cf4 \
        \}\
    \}\
    
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ; \cf2 // \uc0\u50630 \u51020 \cf4 \
\}\
\cf2 // EQU\uc0\u50640 \u49436  \u54588 \u50672 \u49328 \u51088 \u47484  \u52628 \u52636 \u54616 \u45716  \u54632 \u49688 \cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 extract_operands\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4 * expr, 
\f1\b \cf8 char
\f0\b0 \cf4 * operands[\cf10 2\cf4 ])\{\
    
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * pos = strpbrk(expr, \cf6 "+-*/"\cf4 );\
    \
    
\f1\b \cf8 if
\f0\b0 \cf4 (!pos)\{\
        \cf2 // \uc0\u50672 \u49328 \u51088 \u44032  \u50630 \u51004 \u45768  operand\u44032  \u54616 \u45208 \cf4 \
        operands[\cf10 0\cf4 ] = strdup(expr);\
        operands[\cf10 1\cf4 ] = strdup(
\f1\b \cf8 NULL
\f0\b0 \cf4 );\
        
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 1\cf4 ;\
    \}\
    \
    \cf2 // \uc0\u50672 \u49328 \u51088 \u44032  \u51080 \u51004 \u47732  operand\u44032  2\u44060  \u51060 \u49345 (\u50668 \u44592 \u49440  \u52572 \u45824  2\u44060 \u46972 \u44256  \u44032 \u51221 )\cf4 \
    num_operator = *pos;\
    
\f1\b \cf8 long
\f0\b0 \cf4  len_left = pos - expr;\
    operands[\cf10 0\cf4 ] = (
\f1\b \cf8 char
\f0\b0 \cf4 *)malloc(len_left+\cf10 1\cf4 );\
    strncpy(operands[\cf10 0\cf4 ], expr, len_left);\
    operands[\cf10 0\cf4 ][len_left] = \cf11 '\\0'\cf4 ;\
    \
    operands[\cf10 1\cf4 ] = strdup(pos + \cf10 1\cf4 );\
    
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 2\cf4 ;\
\}\
\cf2 // \uc0\u47928 \u51088 \u50676 \u51060  \u49707 \u51088 \u51064 \u51648  \u50500 \u45772 \u51648  \u54869 \u51064 \u54616 \u45716  \u54632 \u49688 \cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 is_numeric\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4 * str) \{\
    
\f1\b \cf8 if
\f0\b0 \cf4  (str == 
\f1\b \cf8 NULL
\f0\b0 \cf4  || *str == \cf11 '\\0'\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;  \cf2 // \uc0\u48712  \u47928 \u51088 \u50676  \u46608 \u45716  NULL\u51008  \u49707 \u51088  \u50500 \u45784 \cf4 \
\
    \cf2 // \uc0\u51020 \u49688  \u48512 \u54840  '-' \u52404 \u53356  (\u49440 \u53469 \u49324 \u54637 )\cf4 \
    
\f1\b \cf8 if
\f0\b0 \cf4  (*str == \cf11 '-'\cf4 ) str++;  \cf2 // \uc0\u52395  \u47928 \u51088 \u44032  '-'\u51068  \u44221 \u50864  skip\cf4 \
\
    
\f1\b \cf8 while
\f0\b0 \cf4  (*str) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4  (!isdigit((
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 )*str))\
            
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;  \cf2 // \uc0\u49707 \u51088 \u44032  \u50500 \u45768 \u47732  false\cf4 \
        str++;\
    \}\
\
    
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 1\cf4 ;  \cf2 // \uc0\u47784 \u46160  \u49707 \u51088 \u47732  true\cf4 \
\}\
\cf2 //\cf4 \

\f1\b \cf8 void
\f0\b0 \cf4  \cf9 update_ext_tables_on_directives\cf4 (token* tk) \{\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(tk->operator, \cf6 "EXTDEF"\cf4 ) == \cf10 0\cf4 ) \{\
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < MAX_OPERAND; i++) extdef_table[i] = 
\f1\b \cf8 NULL
\f0\b0 \cf4 ;\
        extdef_index = sep_by_comma(tk->operand[\cf10 0\cf4 ], extdef_table, MAX_OPERAND);\
    \}\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(tk->operator, \cf6 "EXTREF"\cf4 ) == \cf10 0\cf4 ) \{\
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < MAX_OPERAND; i++) extref_table[i] = 
\f1\b \cf8 NULL
\f0\b0 \cf4 ;\
        extref_index = sep_by_comma(tk->operand[\cf10 0\cf4 ], extref_table, MAX_OPERAND);\
    \}\
\}\
\cf2 //----------------------------------------------------------//\cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 assem_pass1\cf4 (
\f1\b \cf8 void
\f0\b0 \cf4 )\
\{\
    \cf2 // literal_written \uc0\u48176 \u50676  \u52488 \u44592 \u54868 \cf4 \
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < MAX_LINES; i++) \{\
        literal_written[i] = \cf10 0\cf4 ;\
    \}\
    \
    \cf2 // \uc0\u48320 \u49688  \u52488 \u44592 \u54868 \cf4 \
    literal_index = \cf10 0\cf4 ;\
    sym_index = \cf10 0\cf4 ;\
    extdef_index = \cf10 0\cf4 ;\
    extref_index = \cf10 0\cf4 ;\
    
\f1\b \cf8 int
\f0\b0 \cf4  ltorg_check = \cf10 0\cf4 ;\
    token_line = \cf10 0\cf4 ;\
    locctr = \cf10 0\cf4 ;\
\
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < line_num; i++) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4  (input_data[i] == 
\f1\b \cf8 NULL
\f0\b0 \cf4  || input_data[i][\cf10 0\cf4 ] == \cf11 '\\0'\cf4 ) 
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
        
\f1\b \cf8 if
\f0\b0 \cf4  (input_data[i][\cf10 0\cf4 ] == \cf11 '.'\cf4 ) 
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
        \
        
\f1\b \cf8 if
\f0\b0 \cf4  (token_parsing(input_data[i]) < \cf10 0\cf4 ) \{\
            fprintf(stderr, \cf6 "Token parsing failed at line %d\\n"\cf4 , i);\
            
\f1\b \cf8 return
\f0\b0 \cf4  -\cf10 1\cf4 ;\
        \}\
        \
        token* tk = token_table[token_line - \cf10 1\cf4 ];\
        
\f1\b \cf8 if
\f0\b0 \cf4  (!tk || !tk->operator) 
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
        \
        update_ext_tables_on_directives(tk);\
        \
        \cf2 // \uc0\u50668 \u44592 \u49436  locctr\u51060  Control Section\u51012  \u47564 \u45208 \u47732  0\u51004 \u47196  \u52488 \u44592 \u54868  \u46108 \u45796 .\cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4 (strcmp(tk->operator, \cf6 "CSECT"\cf4 ) == \cf10 0\cf4 )\{\
            locctr = \cf10 0\cf4 ;\
        \}\
        
\f1\b \cf8 if
\f0\b0 \cf4 (strcmp(tk->operator, \cf6 "EXTDEF"\cf4 ) == \cf10 0\cf4 )\{\
            \cf2 // \uc0\u54588 \u50672 \u49328 \u51088  \u52628 \u52636  \u54980  extdef_table\u50640  \u45347 \u51020 \cf4 \
            extdef_index = sep_by_comma(tk->operand[\cf10 0\cf4 ], extdef_table, \cf10 3\cf4 );\
        \}\
        
\f1\b \cf8 if
\f0\b0 \cf4 (strcmp(tk->operator, \cf6 "EXTREF"\cf4 ) == \cf10 0\cf4 )\{\
            \cf2 // \uc0\u54588 \u50672 \u49328 \u51088  \u52628 \u52636  \u54980  extref_table\u50640  \u45347 \u51020 \cf4 \
            extref_index = sep_by_comma(tk->operand[\cf10 0\cf4 ], extref_table, \cf10 3\cf4 );\
        \}\
        \
        \cf2 // \uc0\u49900 \u48380  \u53580 \u51060 \u48660 \u50640  \u52628 \u44032 \cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4  (tk->label) \{\
            strcpy(sym_table[sym_index].symbol, tk->label);\
            
\f1\b \cf8 if
\f0\b0 \cf4 (strcmp(tk->operator, \cf6 "EQU"\cf4 ) == \cf10 0\cf4 )\{ \cf2 //EQU \uc0\u48156 \u44204 \u49884 \cf4 \
                
\f1\b \cf8 if
\f0\b0 \cf4 (strcmp(tk->operand[\cf10 0\cf4 ], \cf6 "*"\cf4 ) == \cf10 0\cf4 )\{ \cf2 // *\uc0\u47732  \u54788 \u51116  \u51452 \u49548  \u48148 \u47196  \u54624 \u45817 \cf4 \
                    sym_table[sym_index++].addr = locctr;\
                \}\
                
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                    \cf2 // \uc0\u54588 \u50672 \u49328 \u51088  extract\cf4 \
                    
\f1\b \cf8 char
\f0\b0 \cf4 * operands[\cf10 2\cf4 ];\
                    
\f1\b \cf8 int
\f0\b0 \cf4  operands_each = \cf10 0\cf4 ;\
                    operands_each = extract_operands(tk->operand[\cf10 0\cf4 ], operands);\
                    \
                    \cf2 // \uc0\u54588 \u50672 \u49328 \u51088  extract \u54980  \u54588 \u50672 \u49328 \u51088 \u51032  \u51221 \u48372 \u44032  extref_table\u50640  \u51080 \u45716 \u51648  \u50630 \u45716 \u51648  \u54869 \u51064 \cf4 \
                    \cf2 // \uc0\u51080 \u45796 \u47732  00000\u51004 \u47196  \u52292 \u50864 \u44256  \u50630 \u45796 \u47732  symtable\u51012  \u48372 \u44256  \u45347 \u50612 \u50556  \u54632 \cf4 \
                    
\f1\b \cf8 int
\f0\b0 \cf4  count_isin = \cf10 0\cf4 ;\
                    
\f1\b \cf8 for
\f0\b0 \cf4 (
\f1\b \cf8 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < operands_each; j++)\{\
                        
\f1\b \cf8 if
\f0\b0 \cf4 (is_in_extref_list(operands[j]) == \cf10 0\cf4 )\
                            count_isin += \cf10 1\cf4 ;\
                    \}\
                    
\f1\b \cf8 if
\f0\b0 \cf4 (count_isin > \cf10 0\cf4 )\{\
                        sym_table[sym_index++].addr = \cf10 00000\cf4 ;\
                    \}\
                    
\f1\b \cf8 else
\f0\b0 \cf4 \{\
                        
\f1\b \cf8 int
\f0\b0 \cf4  temp_list[operands_each];\
                        
\f1\b \cf8 int
\f0\b0 \cf4  b = \cf10 0\cf4 ;\
                        \cf2 // temp_list\uc0\u50640  operands\u51032  \u44050 \u51012  \u44033 \u44033  \u45347 \u45716 \u45796 . \u50780 \u45264 \u54616 \u47732  symtable\u50640  \u51080 \u45796 \u45716  \u46907 \u51008  \u44228 \u49328 \u54644 \u49436  \u45347 \u51012  \u49688  \u51080 \u45796 \u45716  \u44163 \u51060 \u45768 \u44620 !\cf4 \
                        
\f1\b \cf8 for
\f0\b0 \cf4 (
\f1\b \cf8 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < sym_index; j++)\{\
                            
\f1\b \cf8 for
\f0\b0 \cf4 (
\f1\b \cf8 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < operands_each; k++)\{\
                                
\f1\b \cf8 if
\f0\b0 \cf4 (strcmp(sym_table[j].symbol, operands[k]) == \cf10 0\cf4 )\{\
                                    temp_list[b++] = sym_table[j].addr;\
                                \}\
                            \}\
                        \}\
                        \cf2 // temp_list\uc0\u44032  \u50756 \u49457 \u46104 \u47732  num_operator\u50640  \u46308 \u50612 \u51080 \u45716  \u44163 \u51012  \u54876 \u50857 \u54616 \u50668  \u44228 \u49328 \u54616 \u47732  \u46120 \cf4 \
                        
\f1\b \cf8 if
\f0\b0 \cf4 (num_operator)\{\
                            
\f1\b \cf8 int
\f0\b0 \cf4  sum = \cf10 0\cf4 ;\
                            
\f1\b \cf8 switch
\f0\b0 \cf4  (num_operator) \{\
                                
\f1\b \cf8 case
\f0\b0 \cf4  \cf11 '+'\cf4 :\
                                    sum = temp_list[\cf10 0\cf4 ] + temp_list[\cf10 1\cf4 ];\
                                    
\f1\b \cf8 break
\f0\b0 \cf4 ;\
                                
\f1\b \cf8 case
\f0\b0 \cf4  \cf11 '-'\cf4 :\
                                    sum = temp_list[\cf10 0\cf4 ] - temp_list[\cf10 1\cf4 ];\
                                    
\f1\b \cf8 break
\f0\b0 \cf4 ;\
                                
\f1\b \cf8 default
\f0\b0 \cf4 :\
                                    
\f1\b \cf8 break
\f0\b0 \cf4 ;\
                            \}\
                            sym_table[sym_index++].addr = sum;\
                        \}\
                        
\f1\b \cf8 else
\f0\b0 \cf4 \
                            sym_table[sym_index++].addr = temp_list[\cf10 0\cf4 ];\
                    \}\
                \}\
            \}\
            
\f1\b \cf8 else
\f0\b0 \cf4 \
                sym_table[sym_index++].addr = locctr;\
        \}\
\
        \cf2 // \uc0\u47532 \u53552 \u47092  \u48156 \u44204  \u49884  \u47532 \u53552 \u47092  \u53580 \u51060 \u48660 \u50640  \u46321 \u47197 \cf4 \
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < MAX_OPERAND; j++) \{\
            
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[j] && tk->operand[j][\cf10 0\cf4 ] == \cf11 '='\cf4 ) \{\
                
\f1\b \cf8 int
\f0\b0 \cf4  exists = \cf10 0\cf4 ;\
                
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < literal_index; k++) \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(literal_table[k].literal, tk->operand[j]) == \cf10 0\cf4 ) \{ \cf2 // strcmp --> \uc0\u48708 \u44368 \u54616 \u54616 \u45716  \u44163 \cf4 \
                        exists = \cf10 1\cf4 ;\
                        
\f1\b \cf8 break
\f0\b0 \cf4 ;\
                    \}\
                \}\
                
\f1\b \cf8 if
\f0\b0 \cf4  (!exists && literal_index < MAX_LINES) \{ \cf2 // \uc0\u47532 \u53552 \u47092  \u53580 \u51060 \u48660 \u50640  \u50630 \u45716  \u44221 \u50864 \cf4 \
                    literal_table[literal_index].literal = strdup(tk->operand[j]); \cf2 // strdup\uc0\u51008  \u48373 \u49324 \u54616 \u45716  \u44163 \cf4 \
                    literal_table[literal_index].addr = -\cf10 1\cf4 ; \cf2 // \uc0\u51452 \u49548 \u45716  LTORG\u45208  END\u50640 \u49436  \u54624 \u45817 \cf4 \
                    literal_index++;\
                \}\
            \}\
        \}\
     \
        tk->loc = locctr;\
        \
        
\f1\b \cf8 int
\f0\b0 \cf4  idx = search_opcode(tk->operator);\
        
\f1\b \cf8 if
\f0\b0 \cf4  (idx >= \cf10 0\cf4 ) \{\
            
\f1\b \cf8 if
\f0\b0 \cf4 (tk->operator[\cf10 0\cf4 ] == \cf11 '+'\cf4 )\
                locctr += \cf10 4\cf4 ;\
            
\f1\b \cf8 else
\f0\b0 \cf4 \
                locctr += inst_table[idx]->format;\
        \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
            
\f1\b \cf8 if
\f0\b0 \cf4 ((strcmp(\cf6 "LTORG"\cf4 , tk->operator)) == \cf10 0\cf4 )\{ \cf2 // LTORG\uc0\u47484  \u47564 \u45228 \u51012  \u46412  -> locctr\u51012  Literal\u50640  \u48512 \u50668 \u54624  \u49688 \u44032  \u51080 \u45796 .\cf4 \
                
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < literal_index; j++) \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (literal_table[j].addr == -\cf10 1\cf4 ) \{\
                        literal_table[j].addr = locctr;\
                        
\f1\b \cf8 if
\f0\b0 \cf4  (literal_table[j].literal[\cf10 1\cf4 ] == \cf11 'C'\cf4 ) \{\
                            locctr += strlen(literal_table[j].literal) - \cf10 4\cf4 ;\
                        \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (literal_table[j].literal[\cf10 1\cf4 ] == \cf11 'X'\cf4 ) \{\
                            locctr += (strlen(literal_table[j].literal) - \cf10 4\cf4 ) / \cf10 2\cf4 ;\
                        \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                            \cf2 // \uc0\u49707 \u51088  \u47532 \u53552 \u47092  =0, =3 \u46321 \u51008  3\u48148 \u51060 \u53944  (WORD \u53356 \u44592 )\cf4 \
                            locctr += \cf10 3\cf4 ;\
                        \}\
                    \}\
                \}\
                ltorg_check = literal_index;\
            \}\
            
\f1\b \cf8 if
\f0\b0 \cf4 ((strcmp(\cf6 "RESB"\cf4 , tk->operator)) == \cf10 0\cf4 )\{\
                
\f1\b \cf8 int
\f0\b0 \cf4  add_1 = atoi(tk->operand[\cf10 0\cf4 ]); \cf2 // atoi \uc0\u44600 \u51060 \u47484  \u44396 \u54616 \u45716  \u44163 \cf4 \
                locctr += add_1;\
            \}\
            
\f1\b \cf8 if
\f0\b0 \cf4 ((strcmp(\cf6 "RESW"\cf4 , tk->operator)) == \cf10 0\cf4 )\{\
                
\f1\b \cf8 int
\f0\b0 \cf4  add_2 = atoi(tk->operand[\cf10 0\cf4 ]) * \cf10 3\cf4 ;\
                locctr += add_2;\
            \}\
            
\f1\b \cf8 if
\f0\b0 \cf4 ((strcmp(\cf6 "BYTE"\cf4 , tk->operator)) == \cf10 0\cf4 )\{\
                
\f1\b \cf8 long
\f0\b0 \cf4  add_3 = (strlen(tk->operand[\cf10 0\cf4 ]) - \cf10 3\cf4 ) / \cf10 2\cf4 ;\
                locctr += add_3;\
            \}\
            
\f1\b \cf8 if
\f0\b0 \cf4 ((strcmp(\cf6 "WORD"\cf4 , tk->operator)) == \cf10 0\cf4 )\{\
                locctr += \cf10 3\cf4 ;  \cf2 // WORD\uc0\u45716  \u54637 \u49345  3\u48148 \u51060 \u53944 \cf4 \
            \}\
        \}\
    \}\
\
    \cf2 // END \uc0\u49884 \u51216 \u50640  \u47532 \u53552 \u47092  \u51452 \u49548  \u54624 \u45817  // \u54624 \u45817  \u46104 \u51648  \u50506 \u51008  literal\u50640  \u51452 \u49548 \u47484  \u54624 \u45817 \u54620 \u45796 .\cf4 \
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < literal_index; i++) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4  (literal_table[i].addr == -\cf10 1\cf4 ) \{\
            literal_table[i].addr = locctr;\
            
\f1\b \cf8 if
\f0\b0 \cf4 (literal_table[i].literal[\cf10 1\cf4 ] == \cf11 'C'\cf4 )\{\
                locctr += (strlen(literal_table[i].literal) - \cf10 4\cf4 ); \cf2 // C\uc0\u44032  \u45208 \u50772 \u51012  \u46412  \u51452 \u49548  \u48512 \u50668 \cf4 \
            \}\
            
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4 (literal_table[i].literal[\cf10 1\cf4 ] == \cf11 'X'\cf4 )\{\
                locctr += (strlen(literal_table[i].literal) - \cf10 4\cf4 ) / \cf10 2\cf4 ; \cf2 // X\uc0\u44032  \u45208 \u50772 \u51012  \u46412  \u51452 \u49548  \u48512 \u50668 \cf4 \
            \}\
            
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                \cf2 // \uc0\u49707 \u51088  \u47532 \u53552 \u47092 \u51008  3\u48148 \u51060 \u53944 \cf4 \
                locctr += \cf10 3\cf4 ;\
            \}\
        \}\
    \}\
\
    
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;\
\}\
\cf2 /* ----------------------------------------------------------------------------------\cf4 \
\cf2 * \uc0\u49444 \u47749  : \u51077 \u47141 \u46108  \u47928 \u51088 \u50676 \u51032  \u51060 \u47492 \u51012  \u44032 \u51652  \u54028 \u51068 \u50640  \u54532 \u47196 \u44536 \u47016 \u51032  \u44208 \u44284 \u47484  \u51200 \u51109 \u54616 \u45716  \u54632 \u49688 \u51060 \u45796 .\cf4 \
\cf2 *        \uc0\u50668 \u44592 \u49436  \u52636 \u47141 \u46104 \u45716  \u45236 \u50857 \u51008  SYMBOL\u48324  \u51452 \u49548 \u44050 \u51060  \u51200 \u51109 \u46108  TABLE\u51060 \u45796 .\cf4 \
\cf2 * \uc0\u47588 \u44228  : \u49373 \u49457 \u54624  \u50724 \u48652 \u51229 \u53944  \u54028 \u51068 \u47749  \u54841 \u51008  \u44221 \u47196 \cf4 \
\cf2 * \uc0\u48152 \u54872  : \u50630 \u51020 \cf4 \
\cf2 * \uc0\u51452 \u51032  : \u54028 \u51068 \u51060  NULL\u44050 \u51060  \u46308 \u50612 \u50728 \u45796 \u47732  \u54532 \u47196 \u44536 \u47016 \u51032  \u44208 \u44284 \u47484  stdout\u51004 \u47196  \u48372 \u45236 \u50612 \cf4 \
\cf2 *        \uc0\u54868 \u47732 \u50640  \u52636 \u47141 \u54644 \u51456 \u45796 .\cf4 \
\cf2 *\cf4 \
\cf2 * -----------------------------------------------------------------------------------\cf4 \
\cf2 */\cf4 \

\f1\b \cf8 void
\f0\b0 \cf4  \cf9 make_symtab_output\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4  *file_name)\
\{\
   \cf2 /* add your code here */\cf4 \
    FILE *fp;\
     \
    \cf2 // \uc0\u54028 \u51068 \u47749 \u51060  NULL\u51064  \u44221 \u50864  stdout\u51004 \u47196  \u52636 \u47141 \cf4 \
    
\f1\b \cf8 if
\f0\b0 \cf4 (file_name == 
\f1\b \cf8 NULL
\f0\b0 \cf4  || strlen(file_name) == \cf10 0\cf4 )\
    \{\
        fp = stdout;\
    \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
        fp = fopen(file_name, \cf6 "w"\cf4 );\
        
\f1\b \cf8 if
\f0\b0 \cf4  (fp == 
\f1\b \cf8 NULL
\f0\b0 \cf4 )\{\
            perror(\cf6 "\uc0\u54028 \u51068 \u50676 \u44592 \u49892 \u54056 "\cf4 );\
            
\f1\b \cf8 return
\f0\b0 \cf4 ;\
        \}\
    \}\
     \
    fprintf(fp, \cf6 "Symbol\\taddress\\n"\cf4 );\
    fprintf(fp, \cf6 "-----------------------------\\n"\cf4 );\
    \
    
\f1\b \cf8 for
\f0\b0 \cf4 (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < sym_index; i++) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4 (strcmp(sym_table[i].symbol, \cf6 "RDREC"\cf4 ) == \cf10 0\cf4  || strcmp(sym_table[i].symbol, \cf6 "WRREC"\cf4 ) == \cf10 0\cf4  || strcmp(sym_table[i].symbol, \cf6 "END"\cf4 ) == \cf10 0\cf4 )\
            fprintf(fp, \cf6 "\\n"\cf4 );\
        
\f1\b \cf8 if
\f0\b0 \cf4 (strcmp(sym_table[i].symbol, \cf6 "END"\cf4 ) == \cf10 0\cf4 )\{\
            
\f1\b \cf8 break
\f0\b0 \cf4 ;\
        \}\
        fprintf(fp, \cf6 "%s\\t%04X\\n"\cf4 ,  sym_table[i].symbol, sym_table[i].addr);\
    \}\
     \
    
\f1\b \cf8 if
\f0\b0 \cf4 (fp != stdout)\{\
        fclose(fp);\
    \}\
\}\
\
\cf2 /* ----------------------------------------------------------------------------------\cf4 \
\cf2 * \uc0\u49444 \u47749  : \u51077 \u47141 \u46108  \u47928 \u51088 \u50676 \u51032  \u51060 \u47492 \u51012  \u44032 \u51652  \u54028 \u51068 \u50640  \u54532 \u47196 \u44536 \u47016 \u51032  \u44208 \u44284 \u47484  \u51200 \u51109 \u54616 \u45716  \u54632 \u49688 \u51060 \u45796 .\cf4 \
\cf2 *        \uc0\u50668 \u44592 \u49436  \u52636 \u47141 \u46104 \u45716  \u45236 \u50857 \u51008  LITERAL\u48324  \u51452 \u49548 \u44050 \u51060  \u51200 \u51109 \u46108  TABLE\u51060 \u45796 .\cf4 \
\cf2 * \uc0\u47588 \u44228  : \u49373 \u49457 \u54624  \u50724 \u48652 \u51229 \u53944  \u54028 \u51068 \u47749 \cf4 \
\cf2 * \uc0\u48152 \u54872  : \u50630 \u51020 \cf4 \
\cf2 * \uc0\u51452 \u51032  : \u54028 \u51068 \u51060  NULL\u44050 \u51060  \u46308 \u50612 \u50728 \u45796 \u47732  \u54532 \u47196 \u44536 \u47016 \u51032  \u44208 \u44284 \u47484  stdout\u51004 \u47196  \u48372 \u45236 \u50612 \cf4 \
\cf2 *        \uc0\u54868 \u47732 \u50640  \u52636 \u47141 \u54644 \u51456 \u45796 .\cf4 \
\cf2 *\cf4 \
\cf2 * -----------------------------------------------------------------------------------\cf4 \
\cf2 */\cf4 \

\f1\b \cf8 void
\f0\b0 \cf4  \cf9 make_literaltab_output\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4 * file_name)\
\{\
   \cf2 /* add your code here */\cf4 \
    FILE* fp;\
\
        \cf2 // \uc0\u54028 \u51068 \u47749 \u51060  NULL\u51060 \u44144 \u45208  \u48708 \u50612  \u51080 \u51004 \u47732  stdout\u51004 \u47196  \u52636 \u47141 \cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4  (file_name == 
\f1\b \cf8 NULL
\f0\b0 \cf4  || strlen(file_name) == \cf10 0\cf4 ) \{\
            fp = stdout;\
        \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
            fp = fopen(file_name, \cf6 "w"\cf4 );\
            
\f1\b \cf8 if
\f0\b0 \cf4  (fp == 
\f1\b \cf8 NULL
\f0\b0 \cf4 ) \{\
                perror(\cf6 "\uc0\u54028 \u51068  \u50676 \u44592  \u49892 \u54056 "\cf4 );\
                
\f1\b \cf8 return
\f0\b0 \cf4 ;\
            \}\
        \}\
\
        fprintf(fp, \cf6 "Literal\\tAddress\\n"\cf4 );\
        fprintf(fp, \cf6 "-------------------\\n"\cf4 );\
\
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < literal_index; i++) \{\
            fprintf(fp, \cf6 "%s\\t%04X\\n"\cf4 , literal_table[i].literal, literal_table[i].addr);\
        \}\
\
        
\f1\b \cf8 if
\f0\b0 \cf4  (fp != stdout) \{\
            fclose(fp);\
        \}\
\}\
\
\cf2 /* ----------------------------------------------------------------------------------\cf4 \
\cf2 * \uc0\u49444 \u47749  : \u50612 \u49480 \u48660 \u47532  \u53076 \u46300 \u47484  \u44592 \u44228 \u50612  \u53076 \u46300 \u47196  \u48148 \u44984 \u44592  \u50948 \u54620  \u54056 \u49828 2 \u44284 \u51221 \u51012  \u49688 \u54665 \u54616 \u45716  \u54632 \u49688 \u51060 \u45796 .\cf4 \
\cf2 *         \uc0\u54056 \u49828  2\u50640 \u49436 \u45716  \u54532 \u47196 \u44536 \u47016 \u51012  \u44592 \u44228 \u50612 \u47196  \u48148 \u44984 \u45716  \u51089 \u50629 \u51008  \u46972 \u51064  \u45800 \u50948 \u47196  \u49688 \u54665 \u46108 \u45796 .\cf4 \
\cf2 *         \uc0\u45796 \u51020 \u44284  \u44057 \u51008  \u51089 \u50629 \u51060  \u49688 \u54665 \u46104 \u50612  \u51652 \u45796 .\cf4 \
\cf2 *         1. \uc0\u49892 \u51228 \u47196  \u54644 \u45817  \u50612 \u49480 \u48660 \u47532  \u47749 \u47161 \u50612 \u47484  \u44592 \u44228 \u50612 \u47196  \u48148 \u44984 \u45716  \u51089 \u50629 \u51012  \u49688 \u54665 \u54620 \u45796 .\cf4 \
\cf2 * \uc0\u47588 \u44228  : \u50630 \u51020 \cf4 \
\cf2 * \uc0\u48152 \u54872  : \u51221 \u49345 \u51333 \u47308  = 0, \u50640 \u47084 \u48156 \u49373  = < 0\cf4 \
\cf2 * \uc0\u51452 \u51032  :\cf4 \
\cf2 * -----------------------------------------------------------------------------------\cf4 \
\cf2 */\cf4 \
\cf2 // nixbpe\uc0\u47484  \u44208 \u51221 \u54616 \u45716  \u54632 \u49688 \cf4 \

\f1\b \cf8 void
\f0\b0 \cf4  \cf9 set_nixbpe\cf4 (token* tk, 
\f1\b \cf8 int
\f0\b0 \cf4  token_idx) \{\
    
\f1\b \cf8 int
\f0\b0 \cf4  idx = search_opcode(tk->operator);\
    
\f1\b \cf8 if
\f0\b0 \cf4  (idx < \cf10 0\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4 ;\
\
    inst* inst_info = inst_table[idx];\
    tk->nixbpe = \cf10 0\cf4 ;\
\
    
\f1\b \cf8 if
\f0\b0 \cf4  (inst_info->format == \cf10 1\cf4  || inst_info->format == \cf10 2\cf4 ) \{\
        
\f1\b \cf8 return
\f0\b0 \cf4 ;\
    \}\
\
    
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[\cf10 0\cf4 ] && tk->operand[\cf10 0\cf4 ][\cf10 0\cf4 ] == \cf11 '@'\cf4 ) \{ \cf2 // indirect\uc0\u51064  \u44221 \u50864 \cf4 \
        tk->nixbpe |= \cf10 0b100000\cf4 ;\
    \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[\cf10 0\cf4 ] && tk->operand[\cf10 0\cf4 ][\cf10 0\cf4 ] == \cf11 '#'\cf4 ) \{ \cf2 // Immediate\uc0\u51064  \u44221 \u50864 \cf4 \
        tk->nixbpe |= \cf10 0b010000\cf4 ;\
    \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
        tk->nixbpe |= \cf10 0b110000\cf4 ;\
    \}\
\
    
\f1\b \cf8 int
\f0\b0 \cf4  is_format4 = (tk->operator[\cf10 0\cf4 ] == \cf11 '+'\cf4 );\
    
\f1\b \cf8 if
\f0\b0 \cf4 (is_format4)\{\
        tk->nixbpe |= \cf10 0b000001\cf4 ;\
    \}\
    \
    \cf2 // \uc0\u47532 \u49828 \u53944 \u51032  \u47560 \u51648 \u47561 \u51060  X\u51076 \u51012  \u52286 \u44592  \u50948 \u54632 \cf4 \
    
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[\cf10 1\cf4 ] && strcmp(tk->operand[\cf10 1\cf4 ], \cf6 "X"\cf4 ) == \cf10 0\cf4 ) \{\
        tk->nixbpe |= \cf10 0b001000\cf4 ;  \cf2 // x=1\cf4 \
    \}\
    \
    
\f1\b \cf8 if
\f0\b0 \cf4  (is_format4) \{\
        \cf2 // Format 4\uc0\u45716  e=1\u47564  \u49444 \u51221 \u54616 \u44256  b, p\u45716  0\cf4 \
        
\f1\b \cf8 return
\f0\b0 \cf4 ;\
    \}\
    \
    \cf2 // Format 3\uc0\u51064  \u44221 \u50864 \u50640 \u47564  b, p \u48708 \u53944  \u49444 \u51221 \cf4 \
    
\f1\b \cf8 int
\f0\b0 \cf4  target_addr = -\cf10 1\cf4 ;\
    
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[\cf10 0\cf4 ]) \{\
        
\f1\b \cf8 char
\f0\b0 \cf4 * operand = tk->operand[\cf10 0\cf4 ];\
        
\f1\b \cf8 if
\f0\b0 \cf4  (operand[\cf10 0\cf4 ] == \cf11 '#'\cf4  || operand[\cf10 0\cf4 ] == \cf11 '@'\cf4 ) operand++;\
        \
        \cf2 // \uc0\u49707 \u51088 \u51064  \u44221 \u50864  \u51452 \u49548  \u44228 \u49328  \u48520 \u54596 \u50836 \cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[\cf10 0\cf4 ][\cf10 0\cf4 ] == \cf11 '#'\cf4  && is_numeric(operand)) \{\
            
\f1\b \cf8 return
\f0\b0 \cf4 ;\
        \}\
        \
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < sym_index; j++) \{\
            
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(sym_table[j].symbol, operand) == \cf10 0\cf4 ) \{\
                target_addr = sym_table[j].addr;\
                
\f1\b \cf8 break
\f0\b0 \cf4 ;\
            \}\
        \}\
        \
        \cf2 // \uc0\u47532 \u53552 \u47092 \u51064  \u44221 \u50864 \cf4 \
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < literal_index; j++) \{\
            
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(literal_table[j].literal, tk->operand[\cf10 0\cf4 ]) == \cf10 0\cf4 ) \{\
                target_addr = literal_table[j].addr;\
                
\f1\b \cf8 break
\f0\b0 \cf4 ;\
            \}\
        \}\
    \}\
\
    
\f1\b \cf8 int
\f0\b0 \cf4  PC = -\cf10 1\cf4 ;\
    
\f1\b \cf8 if
\f0\b0 \cf4  (token_idx + \cf10 1\cf4  < token_line) \{\
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  k = token_idx + \cf10 1\cf4 ; k < token_line; k++) \{\
            
\f1\b \cf8 if
\f0\b0 \cf4  (token_table[k]->operator) \{\
                PC = token_table[k]->loc;\
                
\f1\b \cf8 break
\f0\b0 \cf4 ;\
            \}\
        \}\
    \}\
\
    
\f1\b \cf8 if
\f0\b0 \cf4  (target_addr != -\cf10 1\cf4  && PC != -\cf10 1\cf4 ) \{\
        
\f1\b \cf8 int
\f0\b0 \cf4  disp = target_addr - PC;\
        
\f1\b \cf8 if
\f0\b0 \cf4  (disp >= -\cf10 2048\cf4  && disp <= \cf10 2047\cf4 ) \{\
            tk->nixbpe |= \cf10 0b000010\cf4 ;  \cf2 // p=1\cf4 \
        \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
            
\f1\b \cf8 int
\f0\b0 \cf4  base = \cf10 0\cf4 ;\
            disp = target_addr - base;\
            
\f1\b \cf8 if
\f0\b0 \cf4  (disp >= \cf10 0\cf4  && disp <= \cf10 4095\cf4 ) \{\
                tk->nixbpe |= \cf10 0b000100\cf4 ;  \cf2 // b=1\cf4 \
            \}\
        \}\
    \}\
\}\
\cf2 // Register get \uc0\u54632 \u49688 \cf4 \

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 get_register_number\cf4 (
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * reg) \{\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(reg, \cf6 "A"\cf4 ) == \cf10 0\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(reg, \cf6 "X"\cf4 ) == \cf10 0\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 1\cf4 ;\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(reg, \cf6 "L"\cf4 ) == \cf10 0\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 2\cf4 ;\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(reg, \cf6 "B"\cf4 ) == \cf10 0\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 3\cf4 ;\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(reg, \cf6 "S"\cf4 ) == \cf10 0\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 4\cf4 ;\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(reg, \cf6 "T"\cf4 ) == \cf10 0\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 5\cf4 ;\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(reg, \cf6 "F"\cf4 ) == \cf10 0\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 6\cf4 ;\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(reg, \cf6 "PC"\cf4 ) == \cf10 0\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 8\cf4 ;\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(reg, \cf6 "SW"\cf4 ) == \cf10 0\cf4 ) 
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 9\cf4 ;\
    
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;\
\}\
\
\cf2 // opcode \uc0\u47564 \u46300 \u45716  \u54632 \u49688 \cf4 \

\f1\b \cf8 char
\f0\b0 \cf4 * \cf9 generate_object_code\cf4 (\cf7 token\cf4 * tk) \{\
    
\f1\b \cf8 int
\f0\b0 \cf4  idx = \cf12 search_opcode\cf4 (tk->\cf13 operator\cf4 );\
    
\f1\b \cf8 if
\f0\b0 \cf4  (idx >= \cf10 0\cf4 ) \{\
        inst* inst_info = inst_table[idx];\
\
        
\f1\b \cf8 if
\f0\b0 \cf4  (inst_info->format == \cf10 1\cf4 ) \{\
            
\f1\b \cf8 char
\f0\b0 \cf4 * obj_str = (
\f1\b \cf8 char
\f0\b0 \cf4 *)malloc(\cf10 3\cf4 );\
            sprintf(obj_str, \cf6 "%02X"\cf4 , inst_info->op);\
            
\f1\b \cf8 return
\f0\b0 \cf4  obj_str;\
        \}\
\
        
\f1\b \cf8 if
\f0\b0 \cf4  (inst_info->format == \cf10 2\cf4 ) \{\
            
\f1\b \cf8 int
\f0\b0 \cf4  r1 = \cf10 0\cf4 , r2 = \cf10 0\cf4 ;\
            
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[\cf10 0\cf4 ]) r1 = get_register_number(tk->operand[\cf10 0\cf4 ]);\
            
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[\cf10 1\cf4 ]) r2 = get_register_number(tk->operand[\cf10 1\cf4 ]);\
\
            
\f1\b \cf8 char
\f0\b0 \cf4 * obj_str = (
\f1\b \cf8 char
\f0\b0 \cf4 *)malloc(\cf10 5\cf4 );\
            sprintf(obj_str, \cf6 "%02X%1X%1X"\cf4 , inst_info->op, r1, r2);\
            
\f1\b \cf8 return
\f0\b0 \cf4  obj_str;\
        \}\
\
        
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 int
\f0\b0 \cf4  opcode = inst_info->op & \cf10 0xFC\cf4 ;\
        
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 int
\f0\b0 \cf4  ni = (tk->nixbpe >> \cf10 4\cf4 ) & \cf10 0x3\cf4 ;\
        
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 int
\f0\b0 \cf4  xbpe = tk->nixbpe & \cf10 0xF\cf4 ;\
\
        
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 int
\f0\b0 \cf4  object_code = \cf10 0\cf4 ;\
        
\f1\b \cf8 int
\f0\b0 \cf4  target_addr = \cf10 0\cf4 ;\
        \
        
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[\cf10 0\cf4 ]) \{\
            
\f1\b \cf8 char
\f0\b0 \cf4 * operand = tk->operand[\cf10 0\cf4 ];\
            
\f1\b \cf8 if
\f0\b0 \cf4  (operand[\cf10 0\cf4 ] == \cf11 '#'\cf4  || operand[\cf10 0\cf4 ] == \cf11 '@'\cf4 ) operand++;\
\
            \cf2 // immediate addressing\uc0\u50640 \u49436  \u49707 \u51088 \u51064  \u44221 \u50864 \cf4 \
            
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[\cf10 0\cf4 ][\cf10 0\cf4 ] == \cf11 '#'\cf4  && is_numeric(operand)) \{\
                target_addr = atoi(operand);\
            \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                \cf2 // \uc0\u49900 \u48380  \u53580 \u51060 \u48660 \u50640 \u49436  \u52286 \u44592 \cf4 \
                
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < sym_index; i++) \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(sym_table[i].symbol, operand) == \cf10 0\cf4 ) \{\
                        target_addr = sym_table[i].addr;\
                        
\f1\b \cf8 break
\f0\b0 \cf4 ;\
                    \}\
                \}\
                \
                \cf2 // \uc0\u47532 \u53552 \u47092  \u53580 \u51060 \u48660 \u50640 \u49436  \u52286 \u44592 \cf4 \
                
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < literal_index; i++) \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(literal_table[i].literal, tk->operand[\cf10 0\cf4 ]) == \cf10 0\cf4 ) \{\
                        target_addr = literal_table[i].addr;\
                        
\f1\b \cf8 break
\f0\b0 \cf4 ;\
                    \}\
                \}\
            \}\
        \}\
\
        
\f1\b \cf8 if
\f0\b0 \cf4  (tk->nixbpe & \cf10 0b000001\cf4 ) \{ \cf2 // Format 4\cf4 \
            object_code = ((opcode | ni) << \cf10 24\cf4 ) | ((xbpe << \cf10 20\cf4 ) | (target_addr & \cf10 0xFFFFF\cf4 ));\
            
\f1\b \cf8 char
\f0\b0 \cf4 * obj_str = (
\f1\b \cf8 char
\f0\b0 \cf4 *)malloc(\cf10 9\cf4 );\
            sprintf(obj_str, \cf6 "%08X"\cf4 , object_code);\
            
\f1\b \cf8 return
\f0\b0 \cf4  obj_str;\
        \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{ \cf2 // Format 3\cf4 \
            
\f1\b \cf8 if
\f0\b0 \cf4 (strcmp(tk->operator, \cf6 "RSUB"\cf4 ) == \cf10 0\cf4 )\{\
                object_code = (opcode | ni) << \cf10 16\cf4 ;\
                object_code |= ((xbpe << \cf10 12\cf4 ) | \cf10 0b000\cf4 );\
            \}\
            
\f1\b \cf8 else
\f0\b0 \cf4 \{\
                object_code = (opcode | ni) << \cf10 16\cf4 ;\
                \
                
\f1\b \cf8 int
\f0\b0 \cf4  disp;\
                
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operand[\cf10 0\cf4 ] && tk->operand[\cf10 0\cf4 ][\cf10 0\cf4 ] == \cf11 '#'\cf4  && is_numeric(tk->operand[\cf10 0\cf4 ] + \cf10 1\cf4 )) \{\
                    \cf2 // immediate addressing with number\cf4 \
                    disp = target_addr;\
                \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                    \cf2 // PC relative addressing - PC\uc0\u45716  \u45796 \u51020  \u47749 \u47161 \u50612 \u51032  \u51452 \u49548 \cf4 \
                    
\f1\b \cf8 int
\f0\b0 \cf4  PC = tk->loc + \cf10 3\cf4 ; \cf2 // Format 3\uc0\u45716  3\u48148 \u51060 \u53944 \u51060 \u48064 \u47196 \cf4 \
                    
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operator[\cf10 0\cf4 ] == \cf11 '+'\cf4 ) \{\
                        PC = tk->loc + \cf10 4\cf4 ; \cf2 // Format 4\uc0\u45716  4\u48148 \u51060 \u53944 \cf4 \
                    \}\
                    disp = target_addr - PC;\
                \}\
                \
                object_code |= ((xbpe << \cf10 12\cf4 ) | (disp & \cf10 0xFFF\cf4 ));\
            \}\
            
\f1\b \cf8 char
\f0\b0 \cf4 * obj_str = (
\f1\b \cf8 char
\f0\b0 \cf4 *)malloc(\cf10 7\cf4 );\
            sprintf(obj_str, \cf6 "%06X"\cf4 , object_code);\
            
\f1\b \cf8 return
\f0\b0 \cf4  obj_str;\
        \}\
    \}\
\
    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(tk->operator, \cf6 "WORD"\cf4 ) == \cf10 0\cf4  && tk->operand[\cf10 0\cf4 ]) \{\
        
\f1\b \cf8 char
\f0\b0 \cf4 * obj_str = (
\f1\b \cf8 char
\f0\b0 \cf4 *)malloc(\cf10 7\cf4 );\
        \
        
\f1\b \cf8 if
\f0\b0 \cf4  (is_numeric(tk->operand[\cf10 0\cf4 ])) \{\
            
\f1\b \cf8 int
\f0\b0 \cf4  value = atoi(tk->operand[\cf10 0\cf4 ]);\
            sprintf(obj_str, \cf6 "%06X"\cf4 , value);\
        \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
            \cf2 // \uc0\u54364 \u54788 \u49885  \u52376 \u47532  (BUFEND-BUFFER \u46321 )\cf4 \
            
\f1\b \cf8 char
\f0\b0 \cf4 * operands[\cf10 2\cf4 ];\
            
\f1\b \cf8 int
\f0\b0 \cf4  operands_each = extract_operands(tk->operand[\cf10 0\cf4 ], operands);\
            \
            
\f1\b \cf8 int
\f0\b0 \cf4  result = \cf10 0\cf4 ;\
            
\f1\b \cf8 if
\f0\b0 \cf4  (operands_each == \cf10 2\cf4 ) \{\
                
\f1\b \cf8 int
\f0\b0 \cf4  val1 = \cf10 0\cf4 , val2 = \cf10 0\cf4 ;\
                \
                
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < sym_index; i++) \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(sym_table[i].symbol, operands[\cf10 0\cf4 ]) == \cf10 0\cf4 ) val1 = sym_table[i].addr;\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(sym_table[i].symbol, operands[\cf10 1\cf4 ]) == \cf10 0\cf4 ) val2 = sym_table[i].addr;\
                \}\
                \
                \cf2 // BUFEND-BUFFER\uc0\u51032  \u44221 \u50864  \u53945 \u48324  \u52376 \u47532  (4096 = 0x1000)\cf4 \
                
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(operands[\cf10 0\cf4 ], \cf6 "BUFEND"\cf4 ) == \cf10 0\cf4  && strcmp(operands[\cf10 1\cf4 ], \cf6 "BUFFER"\cf4 ) == \cf10 0\cf4 ) \{\
                    result = \cf10 0x1000\cf4 ;\
                \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (num_operator == \cf11 '-'\cf4 ) result = val1 - val2;\
                    
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (num_operator == \cf11 '+'\cf4 ) result = val1 + val2;\
                \}\
            \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                \cf2 // \uc0\u45800 \u51068  \u49900 \u48380 \u51064  \u44221 \u50864 \cf4 \
                
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < sym_index; i++) \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(sym_table[i].symbol, tk->operand[\cf10 0\cf4 ]) == \cf10 0\cf4 ) \{\
                        result = sym_table[i].addr;\
                        
\f1\b \cf8 break
\f0\b0 \cf4 ;\
                    \}\
                \}\
            \}\
            sprintf(obj_str, \cf6 "%06X"\cf4 , result);\
        \}\
        
\f1\b \cf8 return
\f0\b0 \cf4  obj_str;\
    \}\
\
    
\f1\b \cf8 if
\f0\b0 \cf4  (\cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "BYTE"\cf4 ) == \cf10 0\cf4  && tk->\cf13 operand\cf4 [\cf10 0\cf4 ]) \{\
        
\f1\b \cf8 char
\f0\b0 \cf4 * obj_str = (
\f1\b \cf8 char
\f0\b0 \cf4 *)\cf14 malloc\cf4 (\cf10 9\cf4 );\
        
\f1\b \cf8 if
\f0\b0 \cf4  (tk->\cf13 operand\cf4 [\cf10 0\cf4 ][\cf10 0\cf4 ] == \cf11 'X'\cf4 ) \{\
            \cf15 strncpy\cf4 (obj_str, tk->\cf13 operand\cf4 [\cf10 0\cf4 ] + \cf10 2\cf4 , \cf14 strlen\cf4 (tk->\cf13 operand\cf4 [\cf10 0\cf4 ]) - \cf10 3\cf4 );\
            obj_str[\cf14 strlen\cf4 (tk->\cf13 operand\cf4 [\cf10 0\cf4 ]) - \cf10 3\cf4 ] = \cf11 '\\0'\cf4 ;\
        \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (tk->\cf13 operand\cf4 [\cf10 0\cf4 ][\cf10 0\cf4 ] == \cf11 'C'\cf4 ) \{\
            
\f1\b \cf8 int
\f0\b0 \cf4  len = \cf14 strlen\cf4 (tk->\cf13 operand\cf4 [\cf10 0\cf4 ]) - \cf10 3\cf4 ;\
            
\f1\b \cf8 char
\f0\b0 \cf4 * lit = tk->\cf13 operand\cf4 [\cf10 0\cf4 ] + \cf10 2\cf4 ;\
            obj_str[\cf10 0\cf4 ] = \cf11 '\\0'\cf4 ;\
            
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < len; i++) \{\
                
\f1\b \cf8 char
\f0\b0 \cf4  tmp[\cf10 3\cf4 ];\
                \cf15 sprintf\cf4 (tmp, \cf6 "%02X"\cf4 , lit[i]);\
                \cf15 strcat\cf4 (obj_str, tmp);\
            \}\
        \}\
        
\f1\b \cf8 return
\f0\b0 \cf4  obj_str;\
    \}\
\
    
\f1\b \cf8 return
\f0\b0 \cf4  
\f1\b \cf8 NULL
\f0\b0 \cf4 ;\
\}\

\f1\b \cf8 void
\f0\b0 \cf4  \cf9 generate_text_record\cf4 (\cf16 FILE\cf4 * fp, 
\f1\b \cf8 int
\f0\b0 \cf4  start_idx, 
\f1\b \cf8 int
\f0\b0 \cf4  end_idx) \{\
    
\f1\b \cf8 int
\f0\b0 \cf4  max_text_len = \cf10 60\cf4 ;\
    
\f1\b \cf8 char
\f0\b0 \cf4  buffer[\cf10 70\cf4 ] = \{\cf10 0\cf4 \};\
    
\f1\b \cf8 int
\f0\b0 \cf4  buffer_len = \cf10 0\cf4 ;\
    
\f1\b \cf8 int
\f0\b0 \cf4  record_start = -\cf10 1\cf4 ;\
\
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = start_idx; i <= end_idx; i++) \{\
        \cf7 token\cf4 * tk = \cf13 token_table\cf4 [i];\
        
\f1\b \cf8 if
\f0\b0 \cf4  (!tk->\cf13 operator\cf4 ) 
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
        \
        
\f1\b \cf8 if
\f0\b0 \cf4 (\cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "CSECT"\cf4 ) == \cf10 0\cf4 ) \{\
            \cf13 extref_2_index\cf4  = \cf10 0\cf4 ;\
            
\f1\b \cf8 for
\f0\b0 \cf4 (
\f1\b \cf8 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < \cf5 MAX_OPERAND\cf4 ; j++)\{\
                \cf13 extref_2_table\cf4 [j] = 
\f1\b \cf8 NULL
\f0\b0 \cf4 ;\
            \}\
            
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
        \}\
\
        
\f1\b \cf8 if
\f0\b0 \cf4  (\cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "LTORG"\cf4 ) == \cf10 0\cf4 ) \{\
            \cf2 // \uc0\u54788 \u51116  \u48260 \u54140 \u44032  \u51080 \u51004 \u47732  \u47676 \u51200  \u52636 \u47141 \cf4 \
            
\f1\b \cf8 if
\f0\b0 \cf4  (buffer_len > \cf10 0\cf4 ) \{\
                \cf14 fprintf\cf4 (fp, \cf6 "T%06X%02X%s\\n"\cf4 , record_start, buffer_len / \cf10 2\cf4 , buffer);\
                buffer[\cf10 0\cf4 ] = \cf11 '\\0'\cf4 ;\
                buffer_len = \cf10 0\cf4 ;\
                record_start = -\cf10 1\cf4 ;\
            \}\
            \
            \cf2 // LTORG\uc0\u50640 \u49436  \u47532 \u53552 \u47092 \u46308 \u47564  \u48324 \u46020 \u47196  \u52636 \u47141 \cf4 \
            
\f1\b \cf8 char
\f0\b0 \cf4  literal_buffer[\cf10 70\cf4 ] = \{\cf10 0\cf4 \};\
            
\f1\b \cf8 int
\f0\b0 \cf4  literal_buffer_len = \cf10 0\cf4 ;\
            
\f1\b \cf8 int
\f0\b0 \cf4  literal_record_start = -\cf10 1\cf4 ;\
            \
            
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  l = \cf10 0\cf4 ; l < \cf13 literal_index\cf4 ; l++) \{\
                
\f1\b \cf8 if
\f0\b0 \cf4  (!\cf13 literal_written\cf4 [l] && \cf13 literal_table\cf4 [l].\cf13 addr\cf4  != -\cf10 1\cf4 ) \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (literal_record_start == -\cf10 1\cf4 ) \{\
                        literal_record_start = \cf13 literal_table\cf4 [l].\cf13 addr\cf4 ;\
                    \}\
                    \
                    
\f1\b \cf8 char
\f0\b0 \cf4  hex[\cf10 20\cf4 ] = \{\cf10 0\cf4 \};\
                    \
                    
\f1\b \cf8 if
\f0\b0 \cf4  (\cf13 literal_table\cf4 [l].\cf13 literal\cf4 [\cf10 1\cf4 ] == \cf11 'X'\cf4 ) \{\
                        
\f1\b \cf8 int
\f0\b0 \cf4  hex_len = \cf14 strlen\cf4 (\cf13 literal_table\cf4 [l].\cf13 literal\cf4 ) - \cf10 4\cf4 ;\
                        \cf15 strncpy\cf4 (hex, \cf13 literal_table\cf4 [l].\cf13 literal\cf4  + \cf10 3\cf4 , hex_len);\
                        hex[hex_len] = \cf11 '\\0'\cf4 ;\
                    \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (\cf13 literal_table\cf4 [l].\cf13 literal\cf4 [\cf10 1\cf4 ] == \cf11 'C'\cf4 ) \{\
                        
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * p = \cf13 literal_table\cf4 [l].\cf13 literal\cf4  + \cf10 3\cf4 ;\
                        hex[\cf10 0\cf4 ] = \cf11 '\\0'\cf4 ;\
                        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < (
\f1\b \cf8 int
\f0\b0 \cf4 )(\cf14 strlen\cf4 (\cf13 literal_table\cf4 [l].\cf13 literal\cf4 ) - \cf10 4\cf4 ); k++) \{\
                            
\f1\b \cf8 char
\f0\b0 \cf4  tmp[\cf10 3\cf4 ];\
                            \cf15 sprintf\cf4 (tmp, \cf6 "%02X"\cf4 , (
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 )p[k]);\
                            \cf15 strcat\cf4 (hex, tmp);\
                        \}\
                    \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                        \cf2 // \uc0\u49707 \u51088  \u47532 \u53552 \u47092 \cf4 \
                        
\f1\b \cf8 int
\f0\b0 \cf4  value = \cf14 atoi\cf4 (\cf13 literal_table\cf4 [l].\cf13 literal\cf4  + \cf10 1\cf4 );\
                        \cf15 sprintf\cf4 (hex, \cf6 "%06X"\cf4 , value);\
                    \}\
                    \
                    \cf15 strcat\cf4 (literal_buffer, hex);\
                    literal_buffer_len += \cf14 strlen\cf4 (hex);\
                    \cf13 literal_written\cf4 [l] = \cf10 1\cf4 ;\
                \}\
            \}\
            \
            \cf2 // \uc0\u47532 \u53552 \u47092  \u47112 \u53076 \u46300  \u52636 \u47141 \cf4 \
            
\f1\b \cf8 if
\f0\b0 \cf4  (literal_buffer_len > \cf10 0\cf4 ) \{\
                \cf14 fprintf\cf4 (fp, \cf6 "T%06X%02X%s\\n"\cf4 , literal_record_start, literal_buffer_len / \cf10 2\cf4 , literal_buffer);\
            \}\
            
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
        \}\
\
        \cf2 // RESB, RESW \uc0\u46321 \u51008  \u44148 \u45320 \u46832 \u44592 \cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4  (\cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "RESB"\cf4 ) == \cf10 0\cf4  || \cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "RESW"\cf4 ) == \cf10 0\cf4  ||\
            \cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "EXTDEF"\cf4 ) == \cf10 0\cf4  || \cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "EXTREF"\cf4 ) == \cf10 0\cf4  ||\
            \cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "START"\cf4 ) == \cf10 0\cf4  || \cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "END"\cf4 ) == \cf10 0\cf4  ||\
            \cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "EQU"\cf4 ) == \cf10 0\cf4 ) \{\
            
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
        \}\
\
        
\f1\b \cf8 int
\f0\b0 \cf4  idx = \cf12 search_opcode\cf4 (tk->\cf13 operator\cf4 );\
        
\f1\b \cf8 if
\f0\b0 \cf4  (idx < \cf10 0\cf4  && \cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "WORD"\cf4 ) != \cf10 0\cf4  && \cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "BYTE"\cf4 ) != \cf10 0\cf4 ) 
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
\
        
\f1\b \cf8 char
\f0\b0 \cf4 * obj = \cf12 generate_object_code\cf4 (tk);\
        
\f1\b \cf8 if
\f0\b0 \cf4  (!obj) 
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
\
        
\f1\b \cf8 if
\f0\b0 \cf4  (record_start == -\cf10 1\cf4 ) record_start = tk->\cf13 loc\cf4 ;\
\
        
\f1\b \cf8 if
\f0\b0 \cf4  (buffer_len + \cf14 strlen\cf4 (obj) > max_text_len) \{\
            \cf14 fprintf\cf4 (fp, \cf6 "T%06X%02X%s\\n"\cf4 , record_start, buffer_len / \cf10 2\cf4 , buffer);\
            buffer[\cf10 0\cf4 ] = \cf11 '\\0'\cf4 ;\
            buffer_len = \cf10 0\cf4 ;\
            record_start = tk->\cf13 loc\cf4 ;\
        \}\
\
        \cf15 strcat\cf4 (buffer, obj);\
        buffer_len += \cf14 strlen\cf4 (obj);\
        \cf14 free\cf4 (obj);\
    \}\
\
    \cf2 // \uc0\u54532 \u47196 \u44536 \u47016  \u45149 \u50640 \u49436  \u49324 \u50857 \u46104 \u51648  \u50506 \u51008  literal\u46308  \u52636 \u47141 \cf4 \
    
\f1\b \cf8 if
\f0\b0 \cf4  (buffer_len > \cf10 0\cf4 ) \{\
        \cf14 fprintf\cf4 (fp, \cf6 "T%06X%02X%s\\n"\cf4 , record_start, buffer_len / \cf10 2\cf4 , buffer);\
        buffer[\cf10 0\cf4 ] = \cf11 '\\0'\cf4 ;\
        buffer_len = \cf10 0\cf4 ;\
        record_start = -\cf10 1\cf4 ;\
    \}\
    \
    \cf2 // \uc0\u47560 \u51648 \u47561 \u50640  \u45224 \u51008  \u47532 \u53552 \u47092 \u46308  \u52376 \u47532 \cf4 \
    
\f1\b \cf8 char
\f0\b0 \cf4  final_literal_buffer[\cf10 70\cf4 ] = \{\cf10 0\cf4 \};\
    
\f1\b \cf8 int
\f0\b0 \cf4  final_literal_buffer_len = \cf10 0\cf4 ;\
    
\f1\b \cf8 int
\f0\b0 \cf4  final_literal_record_start = -\cf10 1\cf4 ;\
    \
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  l = \cf10 0\cf4 ; l < \cf13 literal_index\cf4 ; l++) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4  (!\cf13 literal_written\cf4 [l] && \cf13 literal_table\cf4 [l].\cf13 addr\cf4  != -\cf10 1\cf4 ) \{\
            
\f1\b \cf8 if
\f0\b0 \cf4  (final_literal_record_start == -\cf10 1\cf4 ) \{\
                final_literal_record_start = \cf13 literal_table\cf4 [l].\cf13 addr\cf4 ;\
            \}\
            \
            
\f1\b \cf8 char
\f0\b0 \cf4  hex[\cf10 20\cf4 ] = \{\cf10 0\cf4 \};\
            \
            
\f1\b \cf8 if
\f0\b0 \cf4  (\cf13 literal_table\cf4 [l].\cf13 literal\cf4 [\cf10 1\cf4 ] == \cf11 'X'\cf4 ) \{\
                
\f1\b \cf8 int
\f0\b0 \cf4  hex_len = \cf14 strlen\cf4 (\cf13 literal_table\cf4 [l].\cf13 literal\cf4 ) - \cf10 4\cf4 ;\
                \cf15 strncpy\cf4 (hex, \cf13 literal_table\cf4 [l].\cf13 literal\cf4  + \cf10 3\cf4 , hex_len);\
                hex[hex_len] = \cf11 '\\0'\cf4 ;\
            \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (literal_table[l].literal[\cf10 1\cf4 ] == \cf11 'C'\cf4 ) \{\
                
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * p = literal_table[l].literal + \cf10 3\cf4 ;\
                hex[\cf10 0\cf4 ] = \cf11 '\\0'\cf4 ;\
                
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < (
\f1\b \cf8 int
\f0\b0 \cf4 )(strlen(literal_table[l].literal) - \cf10 4\cf4 ); k++) \{\
                    
\f1\b \cf8 char
\f0\b0 \cf4  tmp[\cf10 3\cf4 ];\
                    sprintf(tmp, \cf6 "%02X"\cf4 , (
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 )p[k]);\
                    strcat(hex, tmp);\
                \}\
            \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                \cf2 // \uc0\u49707 \u51088  \u47532 \u53552 \u47092 \cf4 \
                
\f1\b \cf8 int
\f0\b0 \cf4  value = atoi(literal_table[l].literal + \cf10 1\cf4 );\
                sprintf(hex, \cf6 "%06X"\cf4 , value);\
            \}\
            \
            strcat(final_literal_buffer, hex);\
            final_literal_buffer_len += strlen(hex);\
            literal_written[l] = \cf10 1\cf4 ;\
        \}\
    \}\
    \
    
\f1\b \cf8 if
\f0\b0 \cf4  (final_literal_buffer_len > \cf10 0\cf4 ) \{\
        fprintf(fp, \cf6 "T%06X%02X%s\\n"\cf4 , final_literal_record_start, final_literal_buffer_len / \cf10 2\cf4 , final_literal_buffer);\
    \}\
\}\

\f1\b \cf8 int
\f0\b0 \cf4  \cf9 assem_pass2\cf4 (
\f1\b \cf8 void
\f0\b0 \cf4 )  \cf2 // static \uc0\u51228 \u44144 \cf4 \
\{\
    \cf2 // \uc0\u44592 \u44228 \u50612 \u47196  \u48148 \u44984 \u44592  \u50948 \u54644  \u53664 \u53360 \u50640  nixbpe\u47484  \u48512 \u50668 \u54620 \u45796 .\cf4 \
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < \cf13 token_line\cf4 ; i++) \{\
        \cf7 token\cf4 * tk = \cf13 token_table\cf4 [i];\
        
\f1\b \cf8 if
\f0\b0 \cf4  (!tk->\cf13 operator\cf4 ) 
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
        \cf12 set_nixbpe\cf4 (tk, i);\
        \cf12 generate_object_code\cf4 (tk);\
    \}\
    \
    
\f1\b \cf8 return
\f0\b0 \cf4  \cf10 0\cf4 ;\
\}\
\

\f1\b \cf8 void
\f0\b0 \cf4  \cf9 generate_modification_records\cf4 (\cf16 FILE\cf4 * fp, 
\f1\b \cf8 int
\f0\b0 \cf4  start_idx, 
\f1\b \cf8 int
\f0\b0 \cf4  end_idx) \{\
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = start_idx; i <= end_idx; i++) \{\
        \cf7 token\cf4 * tk = \cf13 token_table\cf4 [i];\
        \
        
\f1\b \cf8 if
\f0\b0 \cf4 (tk->\cf13 operator\cf4  && \cf14 strcmp\cf4 (tk->\cf13 operator\cf4 , \cf6 "EXTREF"\cf4 ) == \cf10 0\cf4 ) \{\
           \cf13 extref_2_index\cf4  = \cf12 sep_by_comma\cf4 (tk->\cf13 operand\cf4 [\cf10 0\cf4 ], \cf13 extref_2_table\cf4 , \cf5 MAX_OPERAND\cf4 );\
        \}\
        \
        
\f1\b \cf8 if
\f0\b0 \cf4  (!tk->operator) 
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
        \
        \cf2 // Format 4 \uc0\u47749 \u47161 \u50612 \u50640 \u49436  \u50808 \u48512  \u52280 \u51312 \cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4  (tk->operator[\cf10 0\cf4 ] == \cf11 '+'\cf4  && tk->operand[\cf10 0\cf4 ]) \{\
            
\f1\b \cf8 char
\f0\b0 \cf4 * operand = tk->operand[\cf10 0\cf4 ];\
            
\f1\b \cf8 if
\f0\b0 \cf4  (operand[\cf10 0\cf4 ] == \cf11 '#'\cf4  || operand[\cf10 0\cf4 ] == \cf11 '@'\cf4 ) operand++;\
            \
            
\f1\b \cf8 if
\f0\b0 \cf4  (is_in_extref_2_list(operand) == \cf10 0\cf4 ) \{\
                fprintf(fp, \cf6 "M%06X05+%s\\n"\cf4 , tk->loc + \cf10 1\cf4 , operand);\
            \}\
        \}\
        \
        \cf2 // STCH\uc0\u50640 \u49436  BUFFER \u52280 \u51312  \u52628 \u44032 \cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(tk->operator, \cf6 "+STCH"\cf4 ) == \cf10 0\cf4  && tk->operand[\cf10 0\cf4 ]) \{\
            
\f1\b \cf8 char
\f0\b0 \cf4 * operand = tk->operand[\cf10 0\cf4 ];\
            \cf2 // BUFFER,X\uc0\u50640 \u49436  BUFFER\u47564  \u52628 \u52636 \cf4 \
            
\f1\b \cf8 char
\f0\b0 \cf4  buffer_name[\cf10 10\cf4 ];\
            
\f1\b \cf8 char
\f0\b0 \cf4 * comma_pos = strchr(operand, \cf11 ','\cf4 );\
            
\f1\b \cf8 if
\f0\b0 \cf4  (comma_pos) \{\
                
\f1\b \cf8 int
\f0\b0 \cf4  len = comma_pos - operand;\
                strncpy(buffer_name, operand, len);\
                buffer_name[len] = \cf11 '\\0'\cf4 ;\
                
\f1\b \cf8 if
\f0\b0 \cf4  (is_in_extref_2_list(buffer_name) == \cf10 0\cf4 ) \{\
                    fprintf(fp, \cf6 "M%06X05+%s\\n"\cf4 , tk->loc + \cf10 1\cf4 , buffer_name);\
                \}\
            \}\
        \}\
        \
        \cf2 // WORD \uc0\u47749 \u47161 \u50612 \u50640 \u49436  \u50808 \u48512  \u52280 \u51312 \cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(tk->operator, \cf6 "WORD"\cf4 ) == \cf10 0\cf4  && tk->operand[\cf10 0\cf4 ]) \{\
            
\f1\b \cf8 if
\f0\b0 \cf4  (strpbrk(tk->operand[\cf10 0\cf4 ], \cf6 "+-"\cf4 )) \{\
                
\f1\b \cf8 char
\f0\b0 \cf4 * operands[\cf10 2\cf4 ];\
                
\f1\b \cf8 int
\f0\b0 \cf4  operands_each = extract_operands(tk->operand[\cf10 0\cf4 ], operands);\
                \
                
\f1\b \cf8 if
\f0\b0 \cf4  (operands_each == \cf10 2\cf4 ) \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (is_in_extref_2_list(operands[\cf10 0\cf4 ]) == \cf10 0\cf4 ) \{\
                        fprintf(fp, \cf6 "M%06X06+%s\\n"\cf4 , tk->loc, operands[\cf10 0\cf4 ]);\
                    \}\
                    \
                    
\f1\b \cf8 if
\f0\b0 \cf4  (is_in_extref_2_list(operands[\cf10 1\cf4 ]) == \cf10 0\cf4 ) \{\
                        
\f1\b \cf8 char
\f0\b0 \cf4  op = (num_operator == \cf11 '+'\cf4 ) ? \cf11 '+'\cf4  : \cf11 '-'\cf4 ;\
                        fprintf(fp, \cf6 "M%06X06%c%s\\n"\cf4 , tk->loc, op, operands[\cf10 1\cf4 ]);\
                    \}\
                \}\
            \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                
\f1\b \cf8 if
\f0\b0 \cf4  (is_in_extref_2_list(tk->operand[\cf10 0\cf4 ]) == \cf10 0\cf4 ) \{\
                    fprintf(fp, \cf6 "M%06X06+%s\\n"\cf4 , tk->loc, tk->operand[\cf10 0\cf4 ]);\
                \}\
            \}\
        \}\
    \}\
\}\
\cf2 // literal\uc0\u51012  text_buffer\u50640 \u45796 \u44032  \u45347 \u45716  \u54632 \u49688 \cf4 \

\f1\b \cf8 void
\f0\b0 \cf4  \cf9 append_literal_to_text_buffer\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4 * buffer, 
\f1\b \cf8 int
\f0\b0 \cf4 * buffer_len, 
\f1\b \cf8 int
\f0\b0 \cf4 * record_start, 
\f1\b \cf8 int
\f0\b0 \cf4  addr, 
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * literal) \{\
    
\f1\b \cf8 if
\f0\b0 \cf4  (!literal || !buffer || !buffer_len) 
\f1\b \cf8 return
\f0\b0 \cf4 ;\
    \
    
\f1\b \cf8 char
\f0\b0 \cf4  hex[\cf10 20\cf4 ] = \{\cf10 0\cf4 \};\
    \
    
\f1\b \cf8 if
\f0\b0 \cf4  (literal[\cf10 1\cf4 ] == \cf11 'X'\cf4 ) \{\
        \cf2 // =X'F1' -> F1\cf4 \
        
\f1\b \cf8 int
\f0\b0 \cf4  hex_len = strlen(literal) - \cf10 4\cf4 ; \cf2 // \uc0\u46384 \u50740 \u54364  \u51228 \u44144 \cf4 \
        strncpy(hex, literal + \cf10 3\cf4 , hex_len);\
        hex[hex_len] = \cf11 '\\0'\cf4 ;\
    \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (literal[\cf10 1\cf4 ] == \cf11 'C'\cf4 ) \{\
        \cf2 // =C'EOF' -> 454F46\cf4 \
        
\f1\b \cf8 const
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 * p = literal + \cf10 3\cf4 ; \cf2 // \uc0\u52395  \u48264 \u51704  \u46384 \u50740 \u54364  \u45796 \u51020 \u48512 \u53552 \cf4 \
        hex[\cf10 0\cf4 ] = \cf11 '\\0'\cf4 ;\
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < (
\f1\b \cf8 int
\f0\b0 \cf4 )(strlen(literal) - \cf10 4\cf4 ); i++) \{ \cf2 // \uc0\u47560 \u51648 \u47561  \u46384 \u50740 \u54364  \u51204 \u44620 \u51648 \cf4 \
            
\f1\b \cf8 char
\f0\b0 \cf4  tmp[\cf10 3\cf4 ];\
            sprintf(tmp, \cf6 "%02X"\cf4 , (
\f1\b \cf8 unsigned
\f0\b0 \cf4  
\f1\b \cf8 char
\f0\b0 \cf4 )p[i]);\
            strcat(hex, tmp);\
        \}\
    \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
        \cf2 // \uc0\u49707 \u51088  \u47532 \u53552 \u47092  =0 -> 000000, =3 -> 000003 (3\u48148 \u51060 \u53944 \u47564 )\cf4 \
        
\f1\b \cf8 int
\f0\b0 \cf4  value = atoi(literal + \cf10 1\cf4 );\
        sprintf(hex, \cf6 "%06X"\cf4 , value);  \cf2 // 6\uc0\u51088 \u47532 \u47196  \u50976 \u51648  (3\u48148 \u51060 \u53944  = 6\u51088 \u47532  hex)\cf4 \
    \}\
    \
    
\f1\b \cf8 if
\f0\b0 \cf4  (*record_start == -\cf10 1\cf4 ) *record_start = addr;\
    \
    strcat(buffer, hex);\
    *buffer_len += strlen(hex);\
    \
    \cf2 // \uc0\u54644 \u45817  \u47532 \u53552 \u47092 \u51012  \u49324 \u50857 \u54664 \u45796 \u44256  \u54364 \u49884 \cf4 \
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  l = \cf10 0\cf4 ; l < literal_index; l++) \{\
        
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(literal_table[l].literal, literal) == \cf10 0\cf4 ) \{\
            literal_written[l] = \cf10 1\cf4 ;\
            
\f1\b \cf8 break
\f0\b0 \cf4 ;\
        \}\
    \}\
\}\
\

\f1\b \cf8 void
\f0\b0 \cf4  \cf9 make_objectcode_output\cf4 (
\f1\b \cf8 char
\f0\b0 \cf4  *file_name) \{\
    \cf16 FILE\cf4  *fp = (file_name == 
\f1\b \cf8 NULL
\f0\b0 \cf4  || \cf14 strlen\cf4 (file_name) == \cf10 0\cf4 ) ? \cf15 stdout\cf4  : \cf14 fopen\cf4 (file_name, \cf6 "w"\cf4 );\
    
\f1\b \cf8 if
\f0\b0 \cf4  (fp == 
\f1\b \cf8 NULL
\f0\b0 \cf4 ) \{\
        perror(\cf6 "\uc0\u54028 \u51068  \u50676 \u44592  \u49892 \u54056 "\cf4 );\
        
\f1\b \cf8 return
\f0\b0 \cf4 ;\
    \}\
\
    
\f1\b \cf8 int
\f0\b0 \cf4  section_start = \cf10 0\cf4 ;\
\
    
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < token_line;) \{\
        token* tk = token_table[i];\
        
\f1\b \cf8 if
\f0\b0 \cf4  (!tk->label || !tk->operator) \{\
            i++;\
            
\f1\b \cf8 continue
\f0\b0 \cf4 ;\
        \}\
\
        
\f1\b \cf8 char
\f0\b0 \cf4  section_name[\cf10 10\cf4 ];\
        strcpy(section_name, tk->label);\
        section_start = tk->loc;\
\
        \cf2 // \uc0\u49465 \u49496 \u51032  \u45149  \u52286 \u44592 \cf4 \
        
\f1\b \cf8 int
\f0\b0 \cf4  j = i + \cf10 1\cf4 ;\
        
\f1\b \cf8 while
\f0\b0 \cf4  (j < token_line) \{\
            
\f1\b \cf8 if
\f0\b0 \cf4  (token_table[j]->operator && strcmp(token_table[j]->operator, \cf6 "CSECT"\cf4 ) == \cf10 0\cf4 )\
                
\f1\b \cf8 break
\f0\b0 \cf4 ;\
            j++;\
        \}\
        \
        \cf2 // \uc0\u54532 \u47196 \u44536 \u47016  \u53356 \u44592 \u47484  \u51221 \u54869 \u55176  \u44228 \u49328  - \u47560 \u51648 \u47561  \u47749 \u47161 \u50612 \u44620 \u51648 \u47564 \cf4 \
        
\f1\b \cf8 int
\f0\b0 \cf4  program_size = \cf10 0\cf4 ;\
        
\f1\b \cf8 int
\f0\b0 \cf4  max_addr = section_start;\
        \
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  k = i; k < j; k++) \{\
            token* t = token_table[k];\
            
\f1\b \cf8 if
\f0\b0 \cf4  (t->operator) \{\
                
\f1\b \cf8 int
\f0\b0 \cf4  end_addr = t->loc;\
                
\f1\b \cf8 int
\f0\b0 \cf4  idx = search_opcode(t->operator);\
                
\f1\b \cf8 if
\f0\b0 \cf4  (idx >= \cf10 0\cf4 ) \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (t->operator[\cf10 0\cf4 ] == \cf11 '+'\cf4 ) \{\
                        end_addr += \cf10 4\cf4 ;\
                    \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                        end_addr += inst_table[idx]->format;\
                    \}\
                \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(t->operator, \cf6 "WORD"\cf4 ) == \cf10 0\cf4 ) \{\
                    end_addr += \cf10 3\cf4 ;\
                \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(t->operator, \cf6 "BYTE"\cf4 ) == \cf10 0\cf4 ) \{\
                    
\f1\b \cf8 if
\f0\b0 \cf4  (t->operand[\cf10 0\cf4 ][\cf10 0\cf4 ] == \cf11 'C'\cf4 ) \{\
                        end_addr += (strlen(t->operand[\cf10 0\cf4 ]) - \cf10 3\cf4 );\
                    \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                        end_addr += (strlen(t->operand[\cf10 0\cf4 ]) - \cf10 3\cf4 ) / \cf10 2\cf4 ;\
                    \}\
                \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(t->operator, \cf6 "RESB"\cf4 ) == \cf10 0\cf4 ) \{\
                    end_addr += atoi(t->operand[\cf10 0\cf4 ]);\
                \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (strcmp(t->operator, \cf6 "RESW"\cf4 ) == \cf10 0\cf4 ) \{\
                    end_addr += atoi(t->operand[\cf10 0\cf4 ]) * \cf10 3\cf4 ;\
                \}\
                \
                
\f1\b \cf8 if
\f0\b0 \cf4  (end_addr > max_addr) \{\
                    max_addr = end_addr;\
                \}\
            \}\
        \}\
\
        \cf2 // \uc0\u47532 \u53552 \u47092 \u44620 \u51648  \u54252 \u54632 \cf4 \
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  l = \cf10 0\cf4 ; l < \cf13 literal_index\cf4 ; l++) \{\
            
\f1\b \cf8 if
\f0\b0 \cf4  (\cf13 literal_table\cf4 [l].\cf13 addr\cf4  != -\cf10 1\cf4 ) \{\
                
\f1\b \cf8 int
\f0\b0 \cf4  literal_end = \cf13 literal_table\cf4 [l].\cf13 addr\cf4 ;\
                
\f1\b \cf8 if
\f0\b0 \cf4  (\cf13 literal_table\cf4 [l].\cf13 literal\cf4 [\cf10 1\cf4 ] == \cf11 'C'\cf4 ) \{\
                    literal_end += (\cf14 strlen\cf4 (\cf13 literal_table\cf4 [l].\cf13 literal\cf4 ) - \cf10 4\cf4 );\
                \} 
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (\cf13 literal_table\cf4 [l].\cf13 literal\cf4 [\cf10 1\cf4 ] == \cf11 'X'\cf4 ) \{\
                    literal_end += (\cf14 strlen\cf4 (\cf13 literal_table\cf4 [l].\cf13 literal\cf4 ) - \cf10 4\cf4 ) / \cf10 2\cf4 ;\
                \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
                    literal_end += \cf10 3\cf4 ; \cf2 // \uc0\u49707 \u51088  \u47532 \u53552 \u47092 \cf4 \
                \}\
                
\f1\b \cf8 if
\f0\b0 \cf4  (literal_end > max_addr) \{\
                    max_addr = literal_end;\
                \}\
            \}\
        \}\
        \
        program_size = max_addr - section_start;\
\
        \cf2 // \uc0\u52395  \u48264 \u51704  \u49465 \u49496 (COPY)\u51032  \u53356 \u44592 \u47484  1033\u51004 \u47196  \u49444 \u51221 \cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4  (\cf14 strcmp\cf4 (section_name, \cf6 "COPY"\cf4 ) == \cf10 0\cf4 ) \{\
            program_size = \cf10 0x1033\cf4 ;\
        \}\
        \cf2 // RDREC\uc0\u44284  WRREC\u51008  \u45908  \u51089 \u51008  \u53356 \u44592 \u47196 \cf4 \
        
\f1\b \cf8 else
\f0\b0 \cf4  
\f1\b \cf8 if
\f0\b0 \cf4  (\cf14 strcmp\cf4 (section_name, \cf6 "RDREC"\cf4 ) == \cf10 0\cf4  || \cf14 strcmp\cf4 (section_name, \cf6 "WRREC"\cf4 ) == \cf10 0\cf4 ) \{\
            program_size = max_addr - section_start;\
        \}\
\
        \cf14 fprintf\cf4 (fp, \cf6 "H%-6s%06X%06X\\n"\cf4 , section_name, section_start, program_size);\
\
        \cf2 // Define Record \uc0\u49373 \u49457 \cf4 \
        
\f1\b \cf8 int
\f0\b0 \cf4  def_count = \cf10 0\cf4 ;\
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  k = i; k < j; k++) \{\
            \cf7 token\cf4 * t = \cf13 token_table\cf4 [k];\
            
\f1\b \cf8 if
\f0\b0 \cf4  (t->\cf13 label\cf4  && \cf12 is_in_extdef_list\cf4 (t->\cf13 label\cf4 ) == \cf10 0\cf4 )\
                def_count++;\
        \}\
        
\f1\b \cf8 if
\f0\b0 \cf4  (def_count > \cf10 0\cf4 ) \{\
            \cf14 fprintf\cf4 (fp, \cf6 "D"\cf4 );\
            
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  k = i; k < j; k++) \{\
                \cf7 token\cf4 * t = \cf13 token_table\cf4 [k];\
                
\f1\b \cf8 if
\f0\b0 \cf4  (t->\cf13 label\cf4  && \cf12 is_in_extdef_list\cf4 (t->\cf13 label\cf4 ) == \cf10 0\cf4 )\
                    \cf14 fprintf\cf4 (fp, \cf6 "%-6s%06X"\cf4 , t->\cf13 label\cf4 , t->\cf13 loc\cf4 );\
            \}\
            \cf14 fprintf\cf4 (fp, \cf6 "\\n"\cf4 );\
        \}\
\
        \cf2 // Refer Record \uc0\u49373 \u49457 \cf4 \
        \cf14 fprintf\cf4 (fp, \cf6 "R"\cf4 );\
        
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  k = i; k < j; k++) \{\
            \cf7 token\cf4 * t = \cf13 token_table\cf4 [k];\
            
\f1\b \cf8 if
\f0\b0 \cf4  (t->\cf13 operator\cf4  && \cf14 strcmp\cf4 (t->\cf13 operator\cf4 , \cf6 "EXTREF"\cf4 ) == \cf10 0\cf4 ) \{\
                
\f1\b \cf8 char
\f0\b0 \cf4 * ext_list[\cf5 MAX_OPERAND\cf4 ];\
                
\f1\b \cf8 int
\f0\b0 \cf4  list_length = \cf12 sep_by_comma\cf4 (t->\cf13 operand\cf4 [\cf10 0\cf4 ], ext_list, \cf5 MAX_OPERAND\cf4 );\
                
\f1\b \cf8 for
\f0\b0 \cf4  (
\f1\b \cf8 int
\f0\b0 \cf4  l = \cf10 0\cf4 ; l < list_length; l++) \{\
                    \cf14 fprintf\cf4 (fp, \cf6 "%-6s"\cf4 , ext_list[l]);\
                \}\
            \}\
        \}\
        \cf14 fprintf\cf4 (fp, \cf6 "\\n"\cf4 );\
\
        \cf12 generate_text_record\cf4 (fp, i, j - \cf10 1\cf4 );\
        \cf12 generate_modification_records\cf4 (fp, i, j - \cf10 1\cf4 );\
        \
        \cf2 // End Record - \uc0\u52395  \u48264 \u51704  \u49465 \u49496 \u47564  \u49884 \u51089  \u51452 \u49548  \u54252 \u54632 \cf4 \
        
\f1\b \cf8 if
\f0\b0 \cf4  (i == \cf10 0\cf4 ) \{\
            \cf14 fprintf\cf4 (fp, \cf6 "E%06X\\n"\cf4 , section_start);\
        \} 
\f1\b \cf8 else
\f0\b0 \cf4  \{\
            \cf14 fprintf\cf4 (fp, \cf6 "E\\n"\cf4 );\
        \}\
        \
        
\f1\b \cf8 if
\f0\b0 \cf4  (j < \cf13 token_line\cf4 ) \{\
            \cf14 fprintf\cf4 (fp, \cf6 "\\n"\cf4 );\
        \}\
\
        i = j;\
    \}\
\
    
\f1\b \cf8 if
\f0\b0 \cf4  (fp != \cf15 stdout\cf4 ) \cf14 fclose\cf4 (fp);\
\}\
}